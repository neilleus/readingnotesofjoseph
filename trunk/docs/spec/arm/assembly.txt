4.1 ARM GNU常用汇编伪指令介绍
1. abort
.abort: 停止汇编

2. align
.align absexpr1,absexpr2:
以某种对齐方式,在未使用的存储区域填充值. 第一个值表示对齐方式,4, 8,16或32. 第
二个表达式值表示填充的值.

3. if...else...endif
.if
.else
.endif: 条件预编译

4. include
.include "file": 包含指定的头文件, 可以把一个汇编常量定义放在头文件中.

5. comm
.comm  symbol, length:在bss段申请一段命名空间,该段空间的名称叫symbol, 长度
为length. Ld连接器在连接会为它留出空间.

6. data
.data subsection: 说明接下来的定义归属于subsection数据段.

7. equ
.equ symbol, expression: 把某一个符号(symbol)定义成某一个值(expression).该指令并不分配空间.

8. global
.global symbol: 定义一个全局符号, 通常是为ld使用.

9. ascii
.ascii "string": 定义一个字符串并为之分配空间.

10. byte
.byte expressions: 定义一个字节, 并为之分配空间.

11. short
.short expressions: 定义一个短整型, 并为之分配空间.

12. int
.int expressions: 定义一个整型,并为之分配空间.

13 long
.long expressions: 定义一个长整型, 并为之分配空间.

14 word
.word expressions: 定义一个字,并为之分配空间, 4bytes.

15. macro/endm
.macro: 定义一段宏代码, .macro表示代码的开始, .endm表示代码的结束.

16. req
name .req register name: 为寄存器定义一个别名.

17. code
.code [16|32]: 指定指令代码产生的长度, 16表示Thumb指令, 32表示ARM指令.

18. ltorg
.ltorg: 表示当前往下的定义在归于当前段,并为之分配空间.

4.2 ARM GNU专有符号
1. @
表示注释从当前位置到行尾的字符.

2. #
注释掉一整行.

3. ;
新行分隔符.

4.3 操作码

1. NOP
nop
空操作, 相当于MOV r0, r0

2. LDR
ldr <register> , = <expression>
相当于PC寄存器或其它寄存器的长转移.

3.ADR
adr <register> <label>
相于PC寄存器或其它寄存器的小范围转移.

ADRL
adrl <register> <label>
相于PC寄存器或其寄存器的中范围转移.

5 可执行生成说明

5.1 lds文件说明

5.1.1 主要符号说明

1. OUTPUT_FORMAT(bfdname)
	指定输出可执行文件格式.

2. OUTPUT_ARCH(bfdname)

	指定输出可执行文件所运行CPU平台

3. ENTRY(symbol)
	指定可执行文件的入口段

	5.1.2 段定义说明
	1. 段定义格式
	SECTIONS
{ ...
	段名 :
	{
		内容
	}
	...
}

ARM Instruction sets
MVN	bitwise not
MVN (register)
	writes the bitwise inverse of a register value to the destination
	register. The condition flags are updated based on the result.

9.3.5 Opcodes
as implements all the standard ARM opcodes. It also implements several pseudo
opcodes, including several synthetic load instructions.

NOP
                nop
    This pseudo op will always evaluate to a legal ARM instruction that does
    nothing. Currently it will evaluate to MOV r0, r0.


LDR
                ldr <register> , = <expression>
    If expression evaluates to a numeric constant then a MOV or MVN instruction
    will be used in place of the LDR instruction, if the constant can be
    generated by either of these instructions. Otherwise the constant will be
    placed into the nearest literal pool (if it not already there) and a PC
    relative LDR instruction will be generated.

ADR
                adr <register> <label>
    This instruction will load the address of label into the indicated
    register. The instruction will evaluate to a PC relative ADD or SUB
    instruction depending upon where the label is located. If the label
    is out of range, or if it is not defined in the same file (and section)
	as the ADR instruction, then an error will be generated. This
	instruction will not make use of the literal pool.

ADRL
                adrl <register> <label>
    This instruction will load the address of label into the indicated
    register. The instruction will evaluate to one or two PC relative ADD or
    SUB instructions depending upon where the label is located. If a second
    instruction is not needed a NOP instruction will be generated in its
    place, so that this instruction is always 8 bytes long.

    If the label is out of range, or if it is not defined in the same file
    (and section) as the ADRL instruction, then an error will be generated.
    This instruction will not make use of the literal pool. 

For information on the ARM or Thumb instruction sets, see ARM Software
Development Toolkit Reference Manual, Advanced RISC Machines Ltd. 
