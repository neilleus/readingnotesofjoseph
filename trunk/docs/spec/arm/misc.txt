Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

*******************************************************************************
关于嵌入式
*******************************************************************************
Bootloader是嵌入式系统的启动代码，主要用来初始化处理器、传递内核启动参数给内核，
使得内核可以按照传递的参数启动。通常还具有搬运内核代码到RAM并跳转到内核代码地址
执行的功能。

*******************************************************************************
关于ARM
*******************************************************************************
ARM内核功能模块：
    T（Thumb，支持Thumb指令）
    D（Debug，JTAG，可使CPU进入调试模式，从而设置断点，进行单步调试）
    I（Embedded ICE，实现断点和变量观测的逻辑电路部分，包括TAP控制器）
    M（Multiplier，8位乘法器）
    E（DSP Enhancement，提供某些DSP指令）
    J（Jazelle DBX，Java加速模块，甚至可以直接执行某些JAVA指令）
    S（softcore，可综合的软核）

*** 异常和异常向量入口地址
    复位：复位后进入Supervisor模式，只有CPSR和PC是确定态。		0x00
    未定义指令：进入未定义模式						0x04
    软件中断：进入Supvisor模式，常用来实现系统调用以陷入内核		0x08
    预取指中止：进入Abort模式						0x0C
    数据中止：进入Abort模式						0x10
    保留           							0x18
    IRQ：进入IRQ模式							0x18
    FIQ：进入FIQ模式							0x1C
一般异常向量基址是可以配置的，也就是配置为低地址还是高低址。

*** 异常处理过程
    处理过程：
        1) 保存现场，包括处理器当前状态、中断屏蔽位、CPSR寄存器的各条件标志位（
	复制到SPSR）
	2) 设置CPSR中相应的位
	3) 将R14寄存器设置成返回地址，最后将PC设置成该异常的异常向量地址，执行
	异常处理。
	4) 由异常返回，先恢复处理器状态（SPSR->CPSR），然后返回到发生异常中断
	指令的下一条指令处执行，通过将对应模式下连接寄存器R14中的值装载到PC

*** 工作模式
以下两种是正常工作模式
    用户模式：不可执行特权指令，不可切换模式
以下六种是特权模式，特权模式用于处理异常和中断，以及访问受保护的资源。
    系统模式：特权用户模式
以下五种是异常模式，
    FIQ模式：
    IRQ模式：
    Supervisor模式：复位和软中断SWI会进入此模式
    ABORT模式：预取指终止异常和数据访问中止异常会进入此模式
    Undefined模式：执行未定义的指令会进入此模式

*** ARM的寄存器
31个32位通用寄存器：
    R0-R7		一份
    R8-R12		双份（FIQ有专用的一份）
    R13-R14		六份（用户和系统模式共用，五种异常模式专有）
    R15			一份
6个32位状态寄存器：
    CPSR		一份（用户和系统模式共用）
    SPSR		五份（五种异常模式专有）

R13用于存放栈指针SP
R14叫做连接寄存器LR，用于存放子进程的返回地址，在执行BL或BLX指令时拷贝R15的内容
R15是程序计数器
状态寄存器的格式如下：

    31      27      24                   7 6 5 4       0
    +-+-+-+-+-+-+-+-+-+-----------------+-+-+-+-+-+-+-+-+
    |N|Z|C|V|Q| | | |J|   Reserved      |I|F|T|   Mode  |
    +-+-+-+-+-+-+-+-+-+-----------------+-+-+-+-+-+-+-+-+
    N：负数或小于
    Z：为零
    C：进位、借位、扩展？
    V：溢出
    Q：粘滞位溢出？
    J：Jazelle状态位
    I：IRQ禁止位
    F：FIQ禁止位
    T：Thumb状态位
    M：模式位（5位）

ARM的存储系统
    ARM为单地址空间，大小为2^32个8位字节，。ARM是大小端可配置的，默认为小端。
    快速上下文切换技术（FCSE）通过修改系统中不同进程的虚拟地址，避免在进程间切
    换时造成的虚拟地址到物理地址的重映射，从而提高了性能。通常FCSE位于CPU和MMU
    之间。

ARM最小系统
    通常包括Boot选择，电源，复位，时钟，存储器，JTAG接口等电路部分，通常把最小
    系统做成多层核心板（先调稳定了），把外围接口板设计成双层板，然后将这两个系
    统用一个接口连接起来。

*******************************************************************************
关于开发工具和调试
*******************************************************************************
关于硬件调试
    工具箱：万用表，示波器，电烙铁等
    调试方法，注意模块化
        1) 一般从电源供电部分开始，最好单独调试这一块，比如有可能的话切断对后
	端负载的供电，保证各路供电电压正常，然后用示波器测试各路供电电压的纹
	波，一般在50mV以内都算正常。
	2) 然后接上负载，测量各处晶振的工作情况。无源晶振一般波形近于正弦波，
	有源晶振多近于方波。
	3) 调试最小系统，确保JTAG部分的连接正确，测量Flash和SDRAM上的时钟信号，
	执行Reset操作测量CPU的Reset信号。如果工作正确，使用适当软件可以烧写Boot
	Loader了。Boot Loader启动以后就可以通过某个特定外设来烧写文件系统和内
	核了。
	4) 根据具体应用对各外围子系统分别进行调试。
	5) 整体调试
    这是学究式的教条式做法，具体实践中可以灵活变通，实用为王。

*******************************************************************************
关于启动
*******************************************************************************
Boot过程，一般包括
    大小端配置，ARM一般默认为小端格式，但是可以配置为大端格式。一般在上电时确定
    外围内存接口配置，通常对Flash的初始化代码一般都位于bootloader里
    启动模式选择，一般是通过硬件连线来确定的，比如从哪个位置以16位还是32位启动
    内存地址重映射，主要是由于异常向量入口需要重映射。
关于内存重映射，为什么要进行内存重映射？
    CPU设计人员为了简化芯片设计，一般将所有异常入口集中放置在非易失性存储器中，
    并在系统上电时将其映射到一个固定的连续地址空间上。由于读取非易失性存储器的
    速度限制以及可能的位宽不匹配问题引入的性能问题，所以引入了重映射技术。就是
    对已经确立的存储器映射再次修改，即重新分配地址资源。MAP发生在系统上电的时
    候，REMAP则在系统上电稳定后发生，并且REMAP并不是必须的。
    REMAP一般开始于系统的Boot Loader，一般是Boot Loader将非易失性存储器中的异常
    向量复制到主存中，然后执行REMAP命令，将位于主存的异常向量块映射到以称向量表
    地址空间上。这样以后系统产生的异常处理将从主存中开始执行。

*******************************************************************************
关于Boot Loader
*******************************************************************************
一般基于ARM处理器的Linux嵌入式开发，基本都是硬件板卡设计和软件系统设计同步进行。
硬件准备好之后，首先要将Boot Loader，内核，文件系统等移植到硬件系统上。最先一步
就是要移植Boot Loader先启动系统。

Boot Loader的主要工作：初始化板上硬件，收集硬件资源信息以提供给操作系统，引导、
加载操作系统。

常用Boot Loader，可以参见wikipedia上关于它的介绍，要选择适用于嵌入式系统的。
http://en.wikipedia.org/wiki/Comparison_of_boot_loaders
这里只介绍U-Boot，目前该项目位于：
http://www.denx.de/wiki/U-Boot/

*******************************************************************************
关于U-Boot
*******************************************************************************
Universal Boot Loader，历史渊源可以去看它的网站上的介绍。最大特点在于对众多处理
器架构的支持。
U-Boot提供两种模式，启动加载模式（boot loading）和下载模式（downloading）。
U-Boot提供了大量功能，包括以太网支持，BOOTP/TFTP，在线读写FLASH等外设，串口支
持，识别多种二进制格式（ELF32，pImage等），脚本支持，监控等。

U-Boot常用命令
    1) 打印环境变量, printenv
    2) 设置环境变量, setenv
    3) 保存环境变量, saveenv
    4) 通过串口下载, loadb
    5) tftp网络下载，一般要先设置网络环境，然后通过网络下载映像文件到特定位置
    		U-boot> setenv ethaddr xx:xx:xx:xx:xx:xx
		U-boot> setenv ipaddr xx.xx.xx.xx
		U-boot> setenv serverip xx.xx.xx.xx (tftp server address)
		U-boot> tftp xxxxxxxx kernel.bin
    6) 内存操作命令：md, mm, nm, mw, cp, cmp, mtest
    7) 闪存操作命令：protect, erase, flinfo
    8) 文件系统命令：fatls, fatload, nfs
    9) 脚本: run, bootcmd
    a) CPU控制命令：go, bootm, bootp, kgo
    b) 其他命令：usb, help, ?, ping

一般Boot loader的工作流程
    1) 系统复位
    2) 从复位向量地址开始执行，通常是某cpu下面的Start.S汇编代码。这里完成定义
    异常向量表（需要关中断），初始化SDRAM，配置CPU模式，初始化工作时钟等
    3) 把启动代码复制到RAM中，然后进行地址重映射，然后开始执行启动例程（一般用
    C编写），这里初始化各种将要用到板上外设。

移植U-Boot主要是针对特定板子的移植，包括闪存、内存配置，串口配置等。如果有需要
在boot阶段需要启动的特殊硬件模块，那么需要自行添加对应的驱动支持。具体来说一般
需要移植如下几块：
    CPU初始化部分，包括工作频率，时钟模块，大小端配置，Cache初始化
    内存（SDRAM和FLASH）初始化，对应的接口寄存器设置各个参数，Flash初始化
    常用必备外设接口初始化：串口、网卡接口、GPIO接口等
    启动参数修改
    链接编译的地址分配，主要在.lds文件中
    编译参数的修改，主要修改Makefile文件

U-Boot启动执行的顺序是start.S -> board.c -> main.c
可能需要修改的文件包括start.S, mem_setup.S, flash.c, board.c cpu.c makefile,
	armboot.lds等
start.S开始的地方存放中断向量表，最重要的是reset服务程序，即CPU复位后最开始执
行的程序。主要完成系统初始化（时钟，中断控制）；内存访问初始化；转到supervisor
模式，将ARMBoot复制到SDRAM，并重新映射地址。
cpu.c主要完成CPU的初始化，包括Cache的初始化，开中断，软件复位等。
interrupt.c中主要完成中断全局控制函数的定义
config.mk文件
u-boot.lds文件，LDS文件是ld链接器的脚本文件，器中规定了程序入口，各个段的放置
位置信息等，ld脚本的书写方法可以在ld.info::Scripts::中找到。

编译U-Boot过程（在板子已经支持的情况下）
    设置交叉编译器
	$CROSS_COMPILE=arm_linux-
	$export CROSS_COMPILE
    选定特定的板子的配置
	$make NAME_config
    开始编译
	$make all
    得到二进制映像
	u-boot.bin	这是一个未修改的二进制映像
	u-boot		这是一个ELF格式的二进制映像
	u-boot.srec	这是一个摩托罗拉 S-Record格式的映像

移植U-Boot的过程（在板子列表里尚未支持）
    1. 在最上层Makefile和MAKEALL中按照已有的例子为你的板子增加一个配置选项。注
    意按字母顺序排列。
    2. 创建一个目录存放你的板子相关代码，至少需要Makefile, <board>.c, flash.c
    和u-boot.lds
    3. 为你的板子创建一个新的板子配置文件include/configs/<board>.h
       如果是向一个新的CPU移植，那么还需要创建一个CPU相关代码的目录。
    4. 运行make <board>_config
    5. 运行make，然后得到一个u-boot.srec文件
    6. 运行调试

镜像格式
    U-boot可以以两种格式启动
    新的uImage格式（FIT）
    老的uImage格式

*******************************************************************************
关于裸机驱动开发（类似单片机的开发）
*******************************************************************************
关于ARM汇编伪指令
    伪指令，某些指令助记符没有对应的CPU指令。通常伪指令的作用是为完成汇编程序
    做各种准备工作。这些指令仅在汇编过程中起作用。
        符号定义，用于定义汇编程序的变量，对变量进行赋值，定义寄存器名称等操作
	有全局和局部之分
	    GBLA, GBLL, GBLS, LCLA, CN, CP, DN, FN, RLIST, SETA...
	数据定义，用于数据表定义，文字池定义，数据空间分配等。常用DCB/Q/W分配一
	段内存并将其初始化
	    LTORG, MAP, DCB, FIELD, SPACE, DCQ, DCW...
	报告伪操作符，用于汇编报告，常用ASSERT报告断言错误
	    ASSERT, INFO, OPT...
	条件汇编伪操作符，用于条件汇编，宏定义，循环控制等
	    IF, ELSE, ENDIF, WHIL, WEND, MACRO, MEND...
	其他，段定义，入口点设置等
	    AREA	用来定义段
	    ALIGN	用来设定边界对齐
	    ENTRY	指定程序入口
	    CODE16/CODE32	指定指令集
	    END		汇编结束
	    EQU, EXPORT, GLOBAL, IMPORT...

关于模块化汇编语言程序设计
    要注意：全局符号的定义和引用，各个模块间符号的互相调用方法等
    关于全局符号：定义.global xxx  声明.extern xxx
    模块间符号调用，也包括汇编和C的混合调用，包括函数和变量，C语言中要做声明，
    而且必须要求是全局的。
混合语言编程
    一般程序的初始化部分用汇编语言来完成，主要

关于存储器

用途：储存数据，比如代码，数据文件，变量等。

一般嵌入式都会涉及到片内存储器和片外存储器，前次做得单片机的项目就我完全是利用
片内的Flash，RAM以及ROM这些片内存储器。现如今升格成32位的ARM了，FLASH和SDRAM也
顺势就跑到外面来，当然也大了很多，内存相对没有原先的要求那么苛刻了。当然用的SoC
片子里面还是自有它集成的存储器的，I-Cache, D-Cache一个都不少。

关于Flash
概述
    两大类，NOR闪存（源自Intel）和NAND闪存（源自Toshiba）。
    NOR闪存，适合存储少量的代码，支持XIP（execute in place）方式执行。即程序可
    直接运行于闪存。可用于加快系统启动速度。传输效率高，写入擦除慢，接口方便。
    主要占据1~16MB的市场，一般用来存程序代码。
    NAND闪存，单元密度大，写入擦除快，需要特殊管理接口。扎根大容量市场。一般用
    来存数据。
擦写
    无论NOR闪存还是NAND的闪存，都是按块擦写的，但是块的划分大小不同，NOR的可擦
    写次数大约只有NAND的1/10，约10万次。
注意
    所有的FLASH都会受到位交换现象的影响，通常NAND在这方面表现要差于NOR。一般要
    使用错误检测和纠正技术（EDC/ECC）。
连接
    NOR闪存可以像其它存储器一样直接与微处理器相连，并在上面执行代码。NAND则需要
    提供特殊的设备接口。另外NAND要注意如何隔离坏块，防止对坏块的写入。一般在NOR
    闪存上运行代码不需要什么软件支持，但是在NAND软件上运行代码，通常需要驱动程
    序，也就是内存技术驱动程序（MTD），NAND和NOR在写入和擦除时都需要MTD。
常用器件和厂商
    NOR闪存，SST, INTEL, MICRON等。常用型号：28F128, 28F256, 28F640
    NAND闪存，SAMSUNG, MICRON等。常用型号有：29F2G08, 29F4G16等

关于静态随机存储器SRAM
一般用作Cache，快速，价高，集成度相对低，无需刷新，鉴于定位，不做介绍了。

关于动态随机存储器DRAM
一般的主存，利用电容快速充放电来记录数据，比SRAM稍慢，大概1/10速度，集成度高，
需要动态刷新来维持数据。关于SDRAM和DDRAM以及DDR2，DDR3等的区别和具体内容不做
介绍了。
SDRAM指同步动态随机存储器，这里同步指的是和CPU的时钟同步。SDRAM一般在一个方波的
上升沿执行一次读或写操作，而DDR在上升沿和下降沿各执行一次，所以速度可以加倍。


arm指令集

特点：
Load / Store结构（存储器操作仅包括load和store，所有其他操作在寄存器中完成）
32位固定指令宽度
3地址指令格式（即两个源操作数和结果寄存器都独立指定）
每条指令都条件执行
可在单周期执行的单条指令内同时完成一项普通以为操作和一项普通ALU操作

自动变址功能

寄存器模型
用户模式下
R1-R15的15个32位通用寄存器堆，R15为PC寄存器
CPSR的状态寄存器高四位表示N（负数）、Z（零）、 C（进位）、V（溢出）标志

分类介绍：
	+-------------+-------------+-----------+
	| 数据处理指令| 数据传送指令| 控制流指令|
	+-------------+-------------+-----------+

------------------------------------------------------------------------------
数据处理指令：对寄存器内数据进行算术或逻辑操作
	简单寄存器操作
		算术操作: ADD, ADC, SUB, SBC, RSB, RSC
			说明： RSB和RSC分别为反向减法和带进位反向减法
			举例：	ADD r0, r1, r2		; r0 = r1 + r2
				RSB r0, r1, r2		; r0 = r2 - r1
		按位逻辑操作： AND，ORR，EOR，BIC
			说明：按位与，按位或，按位异或，and not
			举例：	BIC r0, r1, r2		; r0 = r1 and not r2
		寄存器传送操作：MOV，MVN
			说明： MVN为按位取反传送
			举例：	MVN r0, r2		; r0 = not r2
		比较操作：CMP，CMN，TST，TEQ
			说明： 比较，取反比较，位测试，测试相等
			举例：	TEQ r1, r2		;
		注意：操作数顺序格式为结果寄存器，第一操作数，第二操作数
	立即数操作：
		说明： 在数字前面加#表示立即数，加#&表示16进制立即数
		举例：	ADD r3, r3, #1		; r3 = r3 + 1
			AND r8, r7, #&ff	; r8 = r7 & 0xFF
	寄存器移位操作：四地址指令
		移位指令：LSL， LSR，ASL，ASR，ROR，RRX
		说明： 逻辑左移，逻辑右移，算术左移，算术右移，循环右移，扩展
			一位的循环右移
		举例：	ADD r3, r2, r1, LSL #3	; r3 = r2 + (r1 << 3)
	设置条件码：
		说明：任何数据处理指令都可以设置条件码（NZCV），比较操作只能设
			置条件码，如果其他数据处理操作要设置条件码，需要增加S
			操作码来指明。
			算术操作（包括CMP，CMN）根据算术运算结果来设置所有标志
			位，逻辑和传送操作不产生有意义的C或V值，这些操作根据结
			果来设置N和Z，保留V，没有移位操作时，保留C；或者当移位
			时，将移位移出的最后位设置为C。
		举例：	ADDS	r2, r2, r0
			ADC	r3, r3, r1
	乘法操作：
		说明： 第二操作数不可以为立即数
			结果寄存器不允许为源寄存器
			如果设置位S，则标志位V保留，标志为C不再有意义。
			长乘的话，高32位有效位放入第二个结果寄存器。
		举例：	MUL r4, r3, r3			; r4 = r3 * r2
			MLA r4, r3, r2, r1		; r4 = r3 * r2 + r1

------------------------------------------------------------------------------
数据传送指令：在ARM寄存器和存储器之间传送数据
	基本数据传送指令
		单寄存器的Load / Store指令
		多寄存器的Load / Store指令
		单寄存器的交换指令：主要用于系统级程序，实现原子操作。
	寻址模式：ARM的数据传送指令包括寄存器间接寻址，基址偏移和基址变址，
		说明：在任何情况下都需要有一个ARM寄存器来寄存地址，该地址靠近
			需要传送数据的地址。
		举例：	LDR r0, [r1]	; r1内数值代表的存储器位置的内容读入r0
			STR r0, [r1]	; 将r0写入r1内数值代表的存储器位置

		前变址（pre-indexed）
			说明：基址寄存器不包含确定地址，在基址上加上不超过4KB
			的偏移量来寻址
			举例：	LDR r0, [r1, #4]	; 寻址r1+4
			自动变址的前变址：
				说明：自动变址时，会同时实现对基址寄存器的修改。
				举例：LDR r0, [r1, #4]!	; 寻址r1+4并将r1+=4
		后变址（post-indexed）
			说明：基址不加偏移寻址，立即数偏移量仅用作基址修正
			举例：	LDR r0, [r1], #4	; 寻址r1，并将r1+=4
	任意字节对齐的指令：LDRB

	多寄存器数据传送和块传送（块传送略）
		说明：同时存取几个寄存器，允许16个寄存器的任意子集合用单条
		指令传送。支持自动变址
		举例：	LDMIA r1, {r0, r2, r5}	;将[r1]，[r1+4]，[r1+8]分别
				读入r0, r2, r5

------------------------------------------------------------------------------
控制流指令
	转移指令（branch）
		说明：无条件转移B，BAL
		举例：	B LABEL		; LABEL为某个位置
	条件转移
		说明：	BEQ	相等
			BNE	不等
			BPL	非负
			BMI	负
			BCC	无进位
			BCS	有进位
			BLO	小于（无符号数）
			BHS	大于等于（无符号数）
			BHI	大于（无符号数）
			BLS	小于等于（无符号数）
			BVC	无溢出（有符号数）
			BVS	有溢出（有符号数）
			BGT	大于（有符号数）
			BGE	大于等于（有符号数）
			BLT	小于（有符号数）
			BLE	小于等于（有符号数）
			和其中BCC和BLO，BCS和BHS的二进制代码相同
	条件执行
		说明：有时可以用条件执行来代替转移，要使用条件执行，要在3字符
			的操作码之后增加2字符的条件码，条件码应该在其他任何
			修正码之前。
		举例：	CMP r0, #5
			ADDNE	r1, r1, r0
			SUBNE	r1, r1, r2
			; 在r0!=5的情况下才会执行后续加减语句
	转移和链接指令和子程序返回指令
		说明：用于跳转并返回，比如子程序，BL指令，注意不能嵌套子程序，
			否则上一级的返回地址将被下一级的返回地址覆盖，这时应该
			把返回地址和变量保存到堆栈上，使用STMFD和LDMFD
	监控程序调用（略）
		说明：软中断相关，可用于提供IO访问
	跳转表（略）
		说明：用于子程序列表较长时，注意要检测跳转表越界

*** 寻址模式
立即寻址
	指令中给出立即数
绝对寻址
	指令中给出数据在存储器中的全部地址
间接寻址
	指令中包含一个存储器位置的二进制地址，该位置存有所需数据的二进制地址
寄存器寻址
	所需数据在寄存器中，指令包含寄存器编号
寄存器间接寻址
	指令中包含寄存器编号，该寄存器内容是数据在存储器中的地址
基址偏移寻址
	指令指定寄存器（基址）和二进制偏移量，偏移量于基址相加得到存储器地址
基址变址寻址
	指令指定寄存器（基址）和另外一个寄存器（变址），变址与基址相加得到存储
	器地址
基址比例变址寻址
	类似前一种，但变址在和基址相加之前要乘以一个常数（通常为数据项的长度，
	通常是2的幂）
堆栈寻址
	一个隐含或指定的寄存器（堆栈指针）指向存储器中某处（堆栈），数据项以
	后进先出的原则写入（压入）或者读出（弹出）

------------------------------------------------------------------------------
参考文献			
主流ARM嵌入式系统设计技术与实例精解
ARM SoC 体系结构
