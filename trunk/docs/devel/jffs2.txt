Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

JFFS2 - Journalling Flash File System version 2
See also: JFFS, LogFS, UBIFS, YAFFS

node：节点，文件系统的逻辑概念
block: 块，是文件系统的逻辑概念。
sector：扇区，也叫擦除块，是个物理概念

*******************
*      特性
*******************
支持NAND闪存，支持硬链接，支持三种压缩算法，性能更高的垃圾回收算法，支持日志。
inode和dirent节点
JFFS2处理block，即闪存的最小擦除单元。
垃圾回收器在后台运行，将脏块（至少包含一个失效节点）转为空闲块（不包含节点）。
缺点：
必须在挂载时扫描所有的节点，这个操作很慢。写很多小块数据时会导致负的压缩比。所
以没有办法确定剩下多少空闲块，这是由于这个依赖于额外数据被压缩的情况和写的顺序。

JFFS2不像之前的闪存文件系统一样在闪存设备上使用一个翻译层来模拟硬盘，而是直接
在闪存芯片上放置文件系统。JFFS2由Red Hat开发，基于Axis Communications AB的JFFS。

与原始JFFS不同，JFFS2单独对待闪存的每个擦除块。它决不会跨块来写节点，也不会处理
有这类节点的文件系统，任何跨擦除块的节点会被JFFS2忽略，因而其包含的数据会丢失。
如果当前块上没有足够的空间写一整个节点的话，JFFS2会把这个空间留空在下一个新的块
上写。JFFS2始终从一个擦除块的开始处写，并且不期望中间有空洞，一个擦除块的任何空
闲空间应该从空闲开始到擦除块尾端都是空闲的。如果JFFS2在一个擦除块的节点s之间发
现了空闲空间，尽管这除了有点浪费外并没有什么坏处，它还是会打印一句话：
jffs2_scan_empty(): Empty block at 0x0012fffc ends at 0x00130000
		    (with 0xe0021985)! Marking dirty
这种情况可能是你用mkfs.jffs2创建JFFS2镜像时提供了错误的擦除块大小（用-e选项）造
成。缺省是64KB，这是你常碰到的擦除块大小，如果以较小的擦除块来创建JFFS2镜像除了
会产生一些抱怨信息外并没什么坏处，当发现了如上信息，那么检查一下你的擦除块大小
参数是否合适。

擦除块概要（Erase Block Summary）
EBS的目的是加速挂在过程。它在每个擦除块尾部保存了概要信息。在挂载的时候不再需要
单独扫描所有的节点以及读取擦除块的所有页面，而只要读取这个小的概要信息就足够了。
这个概要信息保存在一个JFFS2_FEATURE_RWCOMPAT_DELETE节点中，在挂载的时候如果在擦
除块尾部没有概要节点，则会执行原定的扫描过程。
启用EBS时，这个节点在写数据过程中自动生成，但是在用mkfs.jffs2创建了JFFS2镜像之
后你必须用一个叫做sumtool的用户层工具向其中插入概要信息，比如：
    $mkfs.jffs2 -rdir -oout.jffs2 -e128KiB
    $sumtool -iout.jffs2 -oout-sum.jffs2 -e128KiB
EBS可以工作于NOR和NAND闪存，通常来说在NAND闪存和擦除块大的闪存上加速比率要高一
些。

*******************
*   JFFS2 FAQ 
*******************
为什么无法挂载JFFS2并且看到"Magic bitmask 0x1985 not found"错误信息？
如果无法挂载JFFS2文件系统并且看到许多如下消息：
jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000024: 0x2b10
			 instead 
	...
Further such events for this erase block will not be printed
这表示在你闪存设备上的数据不是有效的JFFS2文件系统格式。对此没有唯一解决方案，
但是我们可以尝试提供一些点子来修正此问题。
首先需要回答的第一个问题是，为什么我闪存设备上的数据不正确使得JFFS2拒绝处理它。
可能原因有许多，比如：
(1) 你的闪存设备有严重的bug导致读出的是垃圾而不是有效数据
(2) 你烧写了垃圾数据而不是有效的JFFS2镜像
(3) 你没有正确烧写JFFS2镜像导致你闪存以垃圾结尾，尽管原镜像正确
(4) 你忘了在烧写前先擦除它，等等
不管怎么，JFFS2不会在它能找到正确数据时抱怨，如果它抱怨了，那么它读了错误数据。
一个常见错误是使用/dev/mtdX或者/dev/mtdblockX设备访问NAND闪存上的JFFS2镜像，
比如：
	$cp jffs2_fs.img /dev/mtd2
这是不正确的，因为当处理NAND闪存时必须跳过坏块并且只在NAND页大小的聚集上写。请
使用nandwrite组件替代。
此外，别忘了在烧写镜像前擦除你的闪存。你可以使用flash_eraseall组件来做。它会确
保读回擦除的MTD设备并且检查是否仅仅写了0xFF。
你可以通过在烧写完镜像后将镜像读出来比对的方法来判断是否烧写成功。在nand闪存上
推荐使用nandread组件。
你可以做一下试验来保证JFFS2工作正常，擦除你的MTD设备并且挂载到JFFS2。你会以一个
空间系统结束。拷贝一些文件到这个JFFS2文件系统并且卸载它。然后再挂载，查看是否
成功无错挂载。如果是，那么说明这不太可能是JFFS2的BUG。

可以在硬盘上使用JFFS2吗？

可以在优盘/CF卡等上面使用JFFS2吗？

JFFS2产生信息了，是问题吗？

为什么无法loop挂载一个JFFS2镜像？

挂在JFFS2文件系统需要mtdblock么？

怎样让2.6内核识别JFFS2为根文件系统？

如何保证数据被写入到闪存里面？

如何把镜像烧录到闪存中？

JFFS2怎么处理NAND闪存中将要坏掉的块？

cleanmarker是什么，用来做什么？

如何编译mkfs.jffs2？


---------------------------------------
参考文件:
http://www.linux-mtd.infradead.org/doc/jffs2.html
http://www.linux-mtd.infradead.org/faq/jffs2.html

