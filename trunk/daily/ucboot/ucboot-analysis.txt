******************************************************************************
关于Flash
一个系统内可以有多个bank的flash，每bank的flash有多个sectors。擦写的单位是sector
对每个bank的flash都对应一个flash_info数据结构。
FLASH有哪些属性呢？厂家ID号，设备ID号，大小，块数
EON EN29LV640T，共有8个8KB块（用于顶端和底端引导，硬件决定，T为顶端引导，B为底
端引导），127个64KB块。支持单块保护和块组保护，支持单块擦除和整片擦除。时间参考
值：字写（8us），块擦除（500ms），整块擦除（64s）。
需要保护的内容：monitor区，环境变量区，冗余备份环境变量区
Grocx:
CFG_ENV_ADDR		FLASH_BASE+0x50000
CFG_ENV_OFFSET		0x50000
CFG_ENV_SIZE		0x10000
TEXT_BASE		0x23000000		defined in Makefile

KS8695:
CFG_ENV_ADDR		FLASH_BASE + 0x00020000
TEXT_BASE		0x00F00000		defined in Makefile
数据结构：
typedef struct {} flash_info_t;

flash.c
void flash_protect(int flag, ulong from, ulong to, flash_info_t *info);
void flash_perror(int err);
int flash_write(char *src, ulong addr, ulong cnt);
    将内存的内容拷贝到Flash中，注意这里写的区域必须落在flash内，并且不能有写保
    护的区域。实现判断传入的地址是否合法，是否落在了写保护区域内。然后擦除要写
    的块，然后从addr所在块的起始写入，知道end所在块。擦除是按块擦除的。
flash_info_t *addr2info(ulong addr);
    遍历flash_info数组，查找addr是否位于某个flash_info指向的地址范围内，如果有
    返回该flash_info的地址。

/* cmd_flash.c */
static int abbrev_spec(char *str, flash_info_t **pinfo,
		       int *psf, int *psl);
static int addr_spec(char *arg1, char *arg2
		     ulong *addr_first, ulong *addr_last);
static int flash_fill_sect_ranges(ulong addr_first, ulong addr_last,
				  int *s_first, int *s_last, int *s_count);
int flash_sect_erase(ulong addr_first, ulong addr_last);
int flash_sect_protect(int p, ulong addr_first, ulong addr_last);
int do_flerase(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
int do_flinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
    打印指定或者全部bank的flash的信息，包括厂商型号，大小，块数信息以及每块的
    起始地址和保护位的设置情况。
int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
    设置指定块或者全部块或者指定地址范围的保护标记。

cfi_flash.c
portwidth的变化：在执行CFI QUERY命令时portwidth为16bit，在调用flash_get_size时
会将其该位8bit，这会影响flash_write_cmd()和flash_map()，注意考虑。

MAX_FLASH_BANKS_DETECT
    动态配置
    用来分配足够可能的空间供flash_info使用，确定的flash bank数量在运行时确定。
    运行时通过detect_num_flash_banks()将bank数量存放到一个变量中























******************************************************************************
关于启动


******************************************************************************
关于命令以及命令的自动完成

CONFIG_COMMANDS
CONFIG_AUTOCOMPLETE	根据环境变量来进行自动补全
    			删除这个配置，始终支持自动补全功能

typedef struct cmd_tbl_s cmd_tbl_t;
命令保存在一个（数组）表中，通过链接时段收集作用收集到一起，表的边界为：
	__u_boot_cmd_start, ..., __u_boot_cmd_end
	它们定义在链接器脚本中。

所有命令处理函数有共同的格式如下：
	void function(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);

#define U_BOOT_CMD(name, maxargs, repeat, cmd, usage, long_help)	\
	cmd_tbl_t __u_boot_cmd##name Struct_Section = {...}

static char tmp_buf[MAX_CBSIZE];

int cmd_auto_complete(const char *const prompt, char *buf,
		      int *np, int *colp)
int cmd_get_data_size(char* arg, int default_size)
static int complete_cmdv(int argc, char *argv[], char last_char,
			 int maxv, char *cmdv[])
cmd_tbl_t *find_cmd (const char *cmd)
static int find_common_prefix(char *argv[])
void install_auto_complete(void)
static void install_auto_complete_handler(const char *cmd,
		int (*complete)(int argc, char *argv[], char last_char,
				int maxv, char *cmdv[]))
static int make_argv(char *s, int argvsz, char *argv[])
static void print_argv(const char *banner, const char *leader,
		       const char *sep, int linemax, char *argv[])
int var_complete(int argc, char *argv[], char last_char, int maxv, char *cmdv[])
int do_echo(cmd_tbl_t *cmdtp, int flag,
	    int argc, char *argv[])
int do_help (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
int do_version(cmd_tbl_t *cmdtp, int flag,

关于命令列表
已定义
CONFIG_NET_CMDLINE 
CONFIG_ENV_CMDLINE
CONFIG_FLASH_CMDLINE

CONFIG_LINUX_TAG_CMDLINE
CONFIG_SAVEENV_CMDLINE
CONFIG_CACHE_CMDLINE
CONFIG_LOADB_CMDLINE
CONFIG_BOOTD_CMDLINE
CONFIG_ASKENV_CMDLINE
CONFIG_NAND_CMDLINE
CONFIG_MII_CMDLINE
CONFIG_LOADB_CMDLINE

dcache
icache
bdinfo
flinfo
iminfo
coninfo
imls

bmp		?
echo
help/?

loadb
loads		?
go
run
cmp
cp		可否从dram到flash？
md
mw
protect
erase

reset
version

printenv
saveenv
setenv

boot
bootm
bootp
diskboot	?

rarpboot
tftpboot
ping
dhcp

