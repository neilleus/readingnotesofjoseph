******************************************************************************
关于Flash

一个系统可有多块闪存，每块闪存由多个扇区（sector）构成。扇区是物理擦写单元。
每bank闪存（即每块闪存芯片）对应一个flash_info数据结构。
需要保护的内容：monitor区，环境变量区，备份环境变量区

u-boot通过flash_info_t数据结构来管理闪存信息。

数据结构：
/* 表示闪存芯片信息的数据结构 */
typedef struct{
	ulong	size;			/* 单位：字节 */
	ushort	sector_count;
	ulong	flash_id;		/* device id和manufacture id的组合 */
	ulong	start[MAX_FLASH_SECT];
	uchar	protect[MAX_FLASH_SECT];
#ifdef CONFIG_MTD_CFI
	uchar	portwidth;
	uchar	chipwidth;		/* 闪存实际已连接的数据总线宽度 */
	ushort	buffer_size;
	ulong	erase_blk_tout;
	ulong	write_tout;
	ulong	buffer_write_tout;
	ushort	vendor;			/* 主算法id */
	ushort	cmd_reset;		/* 复位命令码 */
	ushort	interface;		/* QUERY中给出的闪存数据总线宽度 */
	ushort	legacy_unlock;
	uchar	manufacture_id;
	ushort	device_id;
	ushort	device_id2;		/* 扩展设备id */
	ushort	ext_addr;		/* 扩展查询表地址 */
	ushort	cfi_version;
	ushort	cfi_offset;		/* cfi QEERY的偏移地址 */
	ulong	addr_unlock1;
	ulong	addr_unlock2;
	const char *name;
#endif
} flash_info_t;
struct cfi_qry{
	u8	qry[3];			/* 'Q' 'R' 'Y' */
	u16	p_id;			/* 主算法id */
	u16	p_adr;			/* 主算法表地址 */
	u16	a_id;
	u16	a_adr;
	...	;			/* 电气时序信息 */
	u8	dev_size;		/* 闪存大小为：2**dev_size字节 */
	u16	interface_desc;		/* x8-only, x8/x16, x16-only... */
	u16	max_buf_write_size;
	u8	num_erase_regions;	/* 擦除区种类数（分隔的同大小擦除块组
					   也算不同擦除区） */
	u32	erase_region_info[NUM_ERASE_REGIONS];
					/* 32字节分为两部分：
					 * 高16位z：擦除块大小为256*z字节
					 * 低16为y：同大小擦除块数量（y+1）
					 */
} __attribute__((packed));

struct mtd_info{};

flash.c
void flash_protect(int flag, ulong from, ulong to, flash_info_t *info);
void flash_perror(int err);
int flash_write(char *src, ulong addr, ulong cnt);
    将内存的内容拷贝到Flash中，注意这里写的区域必须落在flash内，并且不能有写保
    护的区域。实现判断传入的地址是否合法，是否落在了写保护区域内。然后擦除要写
    的块，然后从addr所在块的起始写入，知道end所在块。擦除是按块擦除的。
flash_info_t *addr2info(ulong addr);
    遍历flash_info数组，查找addr是否位于某个flash_info指向的地址范围内，如果有
    返回该flash_info的地址。

/* cmd_flash.c */
static int abbrev_spec(char *str, flash_info_t **pinfo,
		       int *psf, int *psl);
static int addr_spec(char *arg1, char *arg2
		     ulong *addr_first, ulong *addr_last);
static int flash_fill_sect_ranges(ulong addr_first, ulong addr_last,
				  int *s_first, int *s_last, int *s_count);
int flash_sect_erase(ulong addr_first, ulong addr_last);
int flash_sect_protect(int p, ulong addr_first, ulong addr_last);
int do_flerase(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
int do_flinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
    打印指定或者全部bank的flash的信息，包括厂商型号，大小，块数信息以及每块的
    起始地址和保护位的设置情况。
int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
    设置指定块或者全部块或者指定地址范围的保护标记。

cfi_flash.c
portwidth的变化：在执行CFI QUERY命令时portwidth为16bit，在调用flash_get_size时
会将其该位8bit，这会影响flash_write_cmd()和flash_map()，注意考虑。

MAX_FLASH_BANKS_DETECT
    动态配置
    用来分配足够可能的空间供flash_info使用，确定的flash bank数量在运行时确定。
    运行时通过detect_num_flash_banks()将bank数量存放到一个变量中



******************************************************************************
关于mtd
数据结构:
struct mtd_info {
 *      u_char		type;
 *      uint32_t	flags;		/* 设备可写，位可写，不需擦除，自动锁 */
 *      uint64_t	size
 *      uint32_t	erasesize;
 *      uint32_t	writesize;

        uint32_t	oobsize;	/* Out-of-Band */
        uint32_t	oobavail;

        /* kernel-only stuff */
 *      const char	*name;
 *      int		index;		/* 多个mtd设备时的索引号 */

        struct nand_ecclayout	*ecclayout;
 *      int		numeraseregions;
 *      struct mtd_erase_region_info	*eraseregions;

        /* 闪存操作方法 */
 *      int (*erase)();
        int (*point)();		/* 返回指向指定闪存位置的指针并锁定闪存 */
        void (*unpoint)();	/* 解锁 */
 *      int (*read)();
 *      int (*write)();
        int (*panic_write)();	/* 内核可能panic时采用的写操作 */
        int (*read_oob)();
        int (*write_oob)();
        /* 以下是和闪存保护相关的几个方法 */
        int (*get_fact_prot_info)();
        int (*read_fact_prot_reg)();
        int (*get_user_prot_info)();
        int (*read_user_prot_reg)();
        int (*write_user_prot_reg)();
        int (*lock_user_prot_reg)();

 *      void (*sync)();
 *      int (*lock)();
 *      int (*unlock)();

        /* Power Management */
        int (*suspend)();
        void (*resume)();
        /* Bad block manageme */
        int (*block_isbad)();
        int (*block_markbad)(); 

        /* ECC status information */
        struct mtd_ecc_stats ecc_stats;
        /* Subpage shift (NAND) */
        int subpage_sft;

 *      void *priv;

        struct module *owner;
        int usecount;

        int (*get_device) (struct mtd_info *mtd);
        void (*put_device) (struct mtd_info *mtd);
};

struct mtd_erase_region_info {
	uint64_t	offset;
	uint32_t	erasesize;
	uint32_t	numblocks;
	ungsigned long *lockmap;
};

ioctls
int add_mtd_device(struct mtd_info *mtd);
int del_mtd_device(struct mtd_info *mtd);
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num);
struct mtd_info *get_mtd_device_nm(const char *name);
put_mtd_device(struct mtd_info *mtd);


******************************************************************************
关于启动
******** **********************************************************************
关于命令以及命令的自动完成
        
typedef struct cmd_tbl_s cmd_tbl_t;
命令保存在一个（数组）表中，通过链接时段收集作用收集到一起，表的边界为：
	__u_boot_cmd_start, ..., __u_boot_cmd_end
	它们定义在链接器脚本中。

所有命令处理函数有共同的格式如下：
	void function(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);

#define U_BOOT_CMD(name, maxargs, repeat, cmd, usage, long_help)	\
	cmd_tbl_t __u_boot_cmd##name Struct_Section = {...}

static char tmp_buf[MAX_CBSIZE];

int cmd_auto_complete(const char *const prompt, char *buf,
		      int *np, int *colp)
int cmd_get_data_size(char* arg, int default_size)
static int complete_cmdv(int argc, char *argv[], char last_char,
			 int maxv, char *cmdv[])
cmd_tbl_t *find_cmd (const char *cmd)
static int find_common_prefix(char *argv[])
void install_auto_complete(void)
static void install_auto_complete_handler(const char *cmd,
		int (*complete)(int argc, char *argv[], char last_char,
				int maxv, char *cmdv[]))
static int make_argv(char *s, int argvsz, char *argv[])
static void print_argv(const char *banner, const char *leader,
		       const char *sep, int linemax, char *argv[])
int var_complete(int argc, char *argv[], char last_char, int maxv, char *cmdv[])
int do_echo(cmd_tbl_t *cmdtp, int flag,
	    int argc, char *argv[])
int do_help (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
int do_version(cmd_tbl_t *cmdtp, int flag,

关于命令列表
已定义
CONFIG_NET_CMDLINE 
CONFIG_ENV_CMDLINE
CONFIG_FLASH_CMDLINE

CONFIG_LINUX_TAG_CMDLINE
CONFIG_SAVEENV_CMDLINE
CONFIG_CACHE_CMDLINE
CONFIG_LOADB_CMDLINE
CONFIG_BOOTD_CMDLINE
CONFIG_ASKENV_CMDLINE
CONFIG_NAND_CMDLINE
CONFIG_MII_CMDLINE
CONFIG_LOADB_CMDLINE

dcache
icache
bdinfo
flinfo
iminfo
coninfo
imls

bmp		?
echo
help/?

loadb
loads		?
go
run
cmp
cp		可否从dram到flash？
md
mw
protect
erase

reset
version

printenv
saveenv
setenv

boot
bootm
bootp
diskboot	?

rarpboot
tftpboot
ping
dhcp

