Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

异常和中断有什么不同?
异常由CPU自身产生，产生时必须考虑与处理器时钟同步，而中断为外部硬件产生，是异
步信息。两者的处理非常类似，都需要在内核中处理。

中断处理程序，上半部和下半部
为了快速进行中断处理，将中断处理过程分成上半部和下半部，上半部一般在关中断的情
况下执行，而下半部则在开中断的情况下执行。Linux中狭义的中断处理函数即是中断处理
的上半部。

中断处理程序原型：
    static irqreturn_t intr_handler(int irq, void *dev_id,
				    struct pt_regs *regs);
    返回值有两种IRQ_NONE和IRQ_HANDLED

关于中断处理程序的重入：
    中断处理程序是无需重入的。在处理中断的时候，当前中断对于所有处理器来说都是
    关闭的，也就是说即使在SMP的情况下同一中断也不会嵌套。

关于共享的中断处理程序
    指共享同一中断号的中断处理程序。要求硬件和软件配合需要能够获得是否是它的设
    备产生的中断，注册时需要指定SA_SHIRQ标志，另外对每个共享中断处理程序其
    dev_id参数必须唯一，而不可以是NULL。

关于中断上下文
    中断上下文不要睡眠（不要调用会睡眠的函数）。中断上下文尽量简洁快速。

关于中断处理程序栈
    这是一个配置选项，如果不配置，则中断处理程序共享所中断进程的堆栈，内核栈的
    大小是两页。如果配置了该选项，则原来的两页栈分出一页来交给中断处理程序使用。

内核的中断处理机制
    大部分代码体系结构相关。（略，参见另外的文档）

操作方法：
    注册中断处理函数：
        request_irq();
    卸载中断处理函数
    	free_irq();
    禁止或激活中断
    	local_irq_disable();
	local_irq_enable();
	local_irq_save(flags);
	local_irq_restore(flags);
    禁止指定中断
    	disable_irq();		等待指定中断处理程序执行完毕才返回
	disable_irq_nosync();	不等待
	enable_irq();		不等待
	synchronize_irq();	等待指定中断处理程序执行完毕才返回
    状态查询函数
        irqs_disable();		查看本地处理器的中断是否被禁止
	in_interrupt();		判断是否处于中断上下文或者下半部
	int_irq();		判断内核是否处于中断上下文

******************************************************************************
引入下半部的理由：
    1. 中断是异步的，会打断其它重要代码，应该尽快执行。
    2. 中断多数需要关中断处理，至少关同一中断线上的中断，应该尽快执行
    3. 中断对硬件进行操作，有时限要求
    4. 中断执行于中断上下文，不可阻塞。

为什么在中断上下文中不可阻塞？
    1. 中断不可调度，如果在中断上下文休眠，则无法唤醒它。在中断上下文中没有进
    程的概念，并且在中断上下文中，内核是不可抢占的，如果休眠，一定挂起。
    2. schedule()时会保存当前进程的上下文，中断发生时内核会保存被中断进程的上
    下文，而中断处理会造成环境变化，如果调用schedule()调度保存的就不是当前进程
    的上下文了。
    3. 中断发生频繁，如果多个中断发生睡眠，会导致中断栈溢出，此处要再考虑清楚 
    4. 这只是Linux的设计要求，并非所有操作系统都必须如此实现。

什么是下半部？
将对时间不是那么敏感，和硬件无关，不怕其它中断（尤其是相同中断）中断的任务应该
放置在下半部中延后执行，下半部延后并不是主要目的，主要目的是系统尽量开中断执行

下半部实现方式：
    1. BH方式，这是老式的方式，提供静态创建的32个bottom half组成的链表，通过一
    个bitmap来标识出哪个bottom half可以执行。每个BH在全局范围内同步，即不允许并
    发执行，即使是SMP。优点简单方便。缺点：不灵活，有性能瓶颈。
    2. 任务队列机制（task queue），内核定义一组队列，每个队列包含一个由等待调用
    的函数组成的链表，根据在队列中的位置，这些函数被执行。驱动程序可以把自己的
    下半部注册到合适的队列上去。缺点仍然不太灵活。
    3. 软中断（softirqs），一组静态定义的下半部接口，共32个，允许在所有处理器上
    同时执行，即使类型相同也可以。一般对性能要求非常高时才使用软中断。典型的有
    网络和SCSI，内核定时器和tasklet基于软中断。softirq和tasklet完全取代了BH。
    4. tasklet，基于软中断实现的灵活性强，动态创建的下半部机制。两个不同类型的
    tasklet可以在不同处理器上同时执行，但类型相同的tasklet不可以同时执行。通常
    情况下使用tasklet，可以动态注册。
    5. 工作队列（work queue），取代了任务对列（task queue）。它对要推后执行的
    6. 内核定时器，可将工作推后到某确定的时间段执行。
    工作排队，然后再进程上下文中执行。
当前存在的三种机制：软中断、tasklet、work queue。

软中断的特点：静态分配，可同时执行，不会相互抢占，需要标记后才可执行（通常中断
处理程序会在返回前标记它的软中断），不可睡眠。

软中断何时被检查执行？
    1. 从硬件中断代码返回时
    2. 在ksoftirqd线程中
    3. 在那些显示检查和执行待处理的软中断代码中，比如网络子系统中。
软中断都通过do_softirq()执行，它循环遍历每一个要执行的软中断，调用其处理程序。

tasklet是利用软中断实现的一种下半部机制，和进程没有任何关系。接口更简单，锁保
护要求更低，tasklet由HI_SOFTIRQ和TASKLET_SOFTIRQ代表，通过调用这两个软中的处理
函数tasklet_action和tasklet_hi_action来遍历执行。可以通过tasklet_schedule()函
数并传递给它相应的tasklet_struct指针来调度执行。

ksoftirq软中断内核线程。
在有大量软中断需要处理时被唤起的一组软中断处理线程。

工作队列
它把工作推后，交由一个内核线程执行，工作队列执行于进程上下文，因此工作队列允许
重新调度甚至睡眠。当下半部处理需要重新调度，或者需要获得大量内存，或者需要获取
信号量，或者执行阻塞式IO操作时，可以使用它。如果你不需要用一个内核线程来推后执
行，那么就是用tasklet。
工作队列子系统是一个用于创建内核线程的接口，通过它创建的进程负责执行由内核其它
部分排到队列里的任务。这些线程叫做工作者线程（work thread）。该子系统提供一个
默认的工作者线程来处理这些工作，一般无需使用者自己创建。（详细说明略）

注意：软中断和tasklet的ksoftirq内核线程只是在有大量软中断时才会产生，而它们本身
并不在内核线程的上下文执行。

*** 禁止下半部
为了共享数据安全，单纯禁止下半部是不够的，应该是先得到一把锁然后再禁止下半部的
处理（这是为了确保可以持有锁）。驱动中常用，内核核心代码可能仅需禁止下半部。
local_bh_disable();	/* 禁止所有下半部处理 */
local_bh_enable();	/* 允许所有下半部处理 */
嵌套多次disable时，也要同要多次enable。
这些函数不会禁止工作队列的执行，它位于进程上下文，不会涉及异步执行问题。



---------------------------------------
References:
Linux Kernel Development Chapter 6 中断和中断处理程序
Linux Kernel Development Chapter 7 下半部和推后执行的工作

