Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

******************************************************************************
进程：处于执行期的程序和它所包含的资源的总称。
线程：进程中的活动对象，拥有独立的PC、进程栈和进程寄存器。
内核的调度对象是线程而不是进程。
进程生存期：fork()->exec()->wait()

******************************************************************************
进程状态：
    TASK_RUNNING
	可执行进程，正执行或在运行队列中等待执行
    TASK_INTERRUPTIBLE
	可中断进程，正在睡眠，等待事件，可通过信号唤醒
    TASK_UNINTERRUPTIBLE
	不可中断，正在睡眠，等待事件，不响应信号，使用较少
    TASK_ZOMBIE
	进程已结束（不可调度），但父进程尚未调用wait系统调用
    TASK_STOPPED
	进程停止执行，进程没有运行也不能运行，通常为接收到停止信号或调试中。

数据结构：
    任务队列：存放所有进程描述符的双向循环链表
    进程描述：struct task_struct;	./linux/sched.h
    进程描述符描述：struct thread_info;	./asm/thread_info.h

    Linux利用slab分配器分配task_struct结构，这样可以达到对象复用和缓存着色的目
    的，（关于slab分配器，内存管理的内容，一个内存动态分配和回收的缓存空间）。
    它的位置通过在进程内核栈尾端的thread_info结构定位。有些体系结构会提供访问
    当前task_struct结构位置的寄存器。

操作方法：
    current();		获取当前进程的task_struct结构，宏方法，进程上下文有效
    set_task_state();	设置进程状态，SMP中涉及内存屏障
    set_current_state();设置当前进程状态
    next_task();	访问任务队列中的下一个任务
    prev_task();	访问任务队列中的前一个任务

遍历任务链表，进程链表是一个双向循环链表，可以通过链表操作遍历它。

******************************************************************************
创建进程
    UNIX系把执行新程序分为两个步骤：fork()和exec()；fork()创建当前进程的拷贝，
    exec()把新程序放入拷贝生成的地址空间执行。
创建线程
    线程创建类似进程进程，只是在进行clone系统调用时指出需要共享的资源，典型的
    它们会共享地址空间，文件系统资源，文件描述符和信号处理程序等。
    线程拥有自己的进程描述符，可被调度。
写时拷贝技术
    为了防止拷贝进程数据导致的低效，资源的复制只在需要写入的时候发生，否则父子
    进程以只读方式共享同一个拷贝。实际开销仅有复制父进程的页表以及给子进程创建
    进程描述符。
fork()的实现
    通过clone()系统调用（可以指定许多标志，比如共享的资源之类情况）实现
    fork()->clone()->do_fork()->copy_process()->dup_task_struct()
					      ->get_pid()
    vfork()系统调用，该调用不会拷贝父进程的页表项，子进程作为父进程的一个单独
    的线程在它的地址空间里执行，父进程被阻塞直到子进程退出或执行exec()，子进程
    不能向地址空间写入。写时拷贝技术后该函数可用价值不大。
内核线程
    在内核地址空间运行的进程，可以被调度和抢占，用来在后台执行一些内核任务。
    通过kernel_thread()方法创建内核进程，也是通过调用clone()系统调用创建。

******************************************************************************
进程终止
    一般通过调用系统调用exit()之后，通常main函数返回之后就是exit()函数调用。
    exit()->do_exit()->(更改状态释放各种资源)->schedule().
    TASK_ZOMBIE状态下，保留了进程的内核栈，thread_info结构和task_struct结构。
wait族函数
    通过wait4()系统调用实现，用于父进程获取子进程信息，之后子进程完全终结。
孤儿进程
    父进程在子进程之前退出，会为子进程在当前线程组内找一个父亲，否则init接管。
    do_exit()->notify_parent()->forget_original_parent()（此函数寻父），它会
    遍历子进程链表，为每个子进程重新设置父进程。
关于ptrace
    2.6新特性，如果一个进程被跟踪时，它被设置为调试进程的子进程。

******************************************************************************
进程调度（策略，算法，抢占，上下文切换，实时）
    多任务：非抢占式多任务和抢占式多任务
    （进程的）时间片：进程在被抢占之前能够运行的时间
策略：
    策略决定调度程序何时让什么程序运行
    IO消耗型进程和处理器消耗型进程
    目标：迅速响应，高吞吐量

进程优先级
    调度程序优先调用时间片未用尽且优先级最高的进程
    优先级高，时间片较长，优先调度
    动态优先级，设置基准优先级，然后根据运行表现判断是IO消耗型还是处理器消耗型
    来动态确定优先级。
    nice值，-20到19，越小优先级越高，默认为0。nice值也决定分配的时间长度，越小
    时间片越长。
    实时优先级，可配置值，0~99，任何实时进程优先级都高于普通进程。

时间片
    调度程序提供较长的默认时间片给交互式程序以让它们运行的更频繁，时间更长。时
    间片可以不一次用完，这样可以重复调度多次，进程时间片耗尽以后，只能等待所有
    进程耗尽时间片，然后重新计算所有进程的时间片之后才能再投入运行。
    时间片重算：进程耗尽时间片会被放入过期优先级数组内，在此之前，新的时间片会
    为它计算好，在所有进程的时间片耗尽之后，切换过期数组合活动数组即可。

进程抢占和上下文切换
    不支持抢占的系统无法抢占正在运行的内核级任务，2.6的内核抢占指的就是可抢占
    内核任务。内核抢占会发生在中断返回时；内核代码再次具有可抢占性；内核任务阻
    塞；内核任务显示调用schedule()；后两者原本就支持。
    当一个进程进入TASK_RUNNING状态，内核会检查它的优先级是否高于当前正在运行的
    进程，如果是，则调度程序被唤醒，抢占当前正在运行的进程并运行新的可执行进程。
    当一个进程时间片变为0时，它也会被抢占，调度程序被唤醒以运行一个新的进程。
    上下文切换会切换虚拟内存映射switch_mm()和切换处理器状态包括栈和寄存
    器switch_to()
    schdule()程序的调用点：用户显示调用；进程时间片耗尽且希望重新调度；高优先级
    进程进入可执行状态；中断返回时；返回用户空间时；

调度算法
    O(1)调度算法，不管多少进程，新调度程序采用得每个算法都能在恒定时间内完成。
    O(1)调度算法，关键在于时间片重算上的优化。参见上面的时间片描述。
    SMP支持，每处理器锁和可执行队列，尽量把一组相关任务交给同一个CPU执行
    数据结构：
	struct runqueue;	kernel/sched.c	可执行队列
	可执行队列是给定处理器上的可执行进程的链表，每个处理器一个。
	struct prio_array;	kernel/sched.c	优先级数组
	每个运行队列有两个优先级数组，一个活跃的和一个过期的。
    操作方法
        cpu_rq();	返回给定处理器的可执行队列指针，宏。
	this_rq();	返回当前处理器的可执行队列指针，宏。
	task_rq_lock();	task_rq_unlock();	锁操作要注意加锁解锁顺序
	this_rq_lock(); rq_unlock();
	double_rq_lock(); double_rq_unlock(); 用于避免死锁
schedule()
    选定下一个进程并切换它去执行。独立于每个处理器运行。通过bitmap找到优先级
    最高的那一个可执行程序，如果不是当前进程，则调用context_switch()切换上下文。

动态优先级和时间片重算的实现
    判断进程类型的指标：休眠时间长短，task_struct记录了休眠时间和运行时间两个
    成员。一起使用来判断进程类型。
    时间片重算：父子进程会均分父进程剩余的时间片。重算时，时间片根据优先级按比
    例缩放。默认优先级的时间片长度为100ms。对交互性很强的进程可能会在时间片用
    完后放入活动数组而不是过期数组以增强性能。TASK_INTERACTIVE()宏通过nice值查
    看是否是交互进程。EXPIRED_STARVING()用来判断过期数组是否饥饿，防止强交互性
    进程总是占住CPU导致数组切换长期无法进行。
进程休眠和唤醒
    被阻塞（休眠）的进程处于特殊的不可执行状态。
    可中断和不可中断进程都处于同一个等待队列中。
    休眠进程通过等待队列来管理，该队列是由等待某些事件发生的进程组成的链表。
    wait_queue_head_t.
多处理器情况下的负载均衡：load_balance()函数。

实施调度
    两种实时调度策略SCHED_FIFO和SCHED_RR。非实时的是SCHED_NORMAL。
    SCHED_FIFO不基于时间片，一旦执行会一直执行到主动放弃，优先级高于NORMAL
    SCHED_RR，带有时间片。

调度相关的系统调用（略）

******************************************************************************
系统调用
    抽象；安全；管理方便
    Linux的系统调用作为C库的一部分提供。

    UNIX界面设计格言：提供机制而不是策略
    编程问题切割：需要提供什么功能（机制），怎么实现这些功能（策略）。
    机制和策略由独立部分来分别负责。

系统调用实现：
    举例：asmlinkage long sys_getpid(void);
    这里asmlinkage限定词用于通知编译器仅从栈中提取该函数的参数，所有的系统调用
    都需要这个限定。
    系统调用命名规则：都以sys_开头。
    每个系统调用会被赋予一个系统调用号，所有系统调用存储在sys_call_table中，与
    体系结构相关，系统调用号一旦分配不可更改也不可删除。

系统调用处理程序
    应用程序无法执行内核代码，无法直接调用内核函数，应用程序以某种方式通知系统
    自己需要执行系统调用。
    通知内核的机制靠软中断实现，通过引发一个异常来促使系统切换到内核态执行异常
    处理程序，同时把系统调用号传入（一般通过某个寄存器，x86为eax），这样就可以
    执行系统调用了，除了系统调用号，可能还需要传递调用参数，一般通过寄存器把这
    些参数从用户空间传给内核（x86通过五个寄存器ebx, ecx, edx, esi, edi）。给用
    户的返回值也通过寄存器来传递（x86上为eax）。

参数验证
    要检查系统调用的参数是否合法，以保证安全。
    比如：检查文件描述符、PID等是否有效，检查用户提供的指针是否有效以保证用户
    访问范围的限制。在接收一个用户空间的指针前，内核要保证：
        指针指向的内存区域属于用户空间，进程不能欺骗内核去读内核空间的数据。
	指针指向的内存区域在进程的地址空间内，进程不能欺骗内核去读其它进程的数
	据读或写必须保证指向的内存区域可读或可写。内核提供了两个函数来实现在内
	核和用户空间之间进行数据传递copy_to_user()和copy_from_user()
    检查是否有足够的权限进行操作。

内核在执行系统调用时处于进程上下文，此时内核可以休眠也可以被抢占。要注意可重入
的考虑。

系统调用不可以编译为模块。
