Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

DNS基础
DNS的条目称为资源记录RR（resource record）。
记录类型：
    A		A记录将主机名映射为32位的IPv4地址。
    AAAA	AAAA（4A）记录将主机名映射为128位的IPv6地址，4A代表128/32=4
    PTR		PTR（指针）记录将IP地址映射为主机名，对于IPv4地址，32位地址的
    		4个字节顺序反转，每个字节都转换成它的十进制ASCII值，然后附上
		in-addr.arpa；对于IPv6地址，128位地址中的32个4位组顺序反转，
		每组被转换成相应的16进制ASCII值（0-9，a-f），并附上ip6.int。
    MX		MX记录指定一个主机作为某主机的邮件交换器，当有多个MX记录存在时
    		需按优先级顺序使用，从最小值开始。
    CNAME	代表canonical name（规范名字），其常见用法是为常用服务入ftp和
    		http指派一个CNAME记录。

应用程序通过调用称为解析器库中的函数来与DNS服务器联系，最常见的解析器函数就是
gethostbyname和gethostbyaddr。解析器位于系统库中。
/etc/resolv.conf一般包含本地名字服务器的IP地址。解析器用UDP给本地名字服务器发
查询。不使用DNS也可得到名字和地址信息，一种是静态主机文件，如/etc/hosts，一种
是网络信息系统NIS。

#include <netdb.h>
struct hostent *gethostbyname(const char *hostname);

参数hostname可以是一个主机名也可以是一个点分十进制的IPv4地址或者冒号分隔的IPv6
地址。即如是IP地址，则不进行查询，直接拷贝返回。
出错时这个函数不设置errno，而是将全局整数h_errno设置为定义在头文件<netdb.h>中的
对应错误值。hstrerror转换错误号为字符串。

struct hostent {
	char *h_name;		/* 主机主名字 */
	char **h_aliases;	/* 主机别名列表 */
	int h_addrtype;		/* 主机地址类型：AF_INET还是AF_INET6 */
	int h_length;		/* 地址长度，4或6 */
	char **h_addr_list;	/* 指向IPv4或IPv6地址列表的指针，网络字节序，
				 * 二进制格式的地址 */
};
#define h_addr	h_addr_list[0];	/* 地址列表中的第一个地址 */

函数gethostbyname和gethostbyaddr会返回指向静态数据的指针，这些数据可能被后面的
调用覆盖，拷贝结构struct hostent是不够的，因为可能包含指针，必须进行深度拷贝。

res_init函数和RES_USE_INET6选项
#include <resolv.h>
res_init();
_res.options |= RES_USE_INET6;
这会导致gethostbyname和gethostbyaddr返回IPv6地址。
res_xxx有一族函数

gethostbyname2函数可以指定地址族

#include <netdb.h>
struct hostent *gethostbyaddr(const void *addr, socklen_t len, int family);
参数addr是根据family值而不同的结构指针，可以是struct in_addr *或者
struct in6_addr *，family可选AF_INET或者AF_INET6

#include <sys/utsname.h>
int uname(struct ustname *buf);
返回的内容存放在传入的buf中。
确定本机IP，可以调用uname获得本机名字，然后调用gethostbyname获得本机的所有IP。
确定本机IP的另一个方法是ioctl的命令SIOCGIFCONF。

#include <unistd.h>
int gethostname(char *name, size_t namelen);
返回当前主机名字。

#include <netdb.h>
struct servent *getservbyname(const char *servname, cosnt char *protoname);
struct servent *getservbyport(int port, const char *protoname);
参数servname必须指定，如果同时指定了protoname，则结果表项必须有匹配的协议。
如果没有指定protoname且服务支持多个协议（UDP和TCP），则返回哪个端口依赖于实现。
struct servent {
	char *s_name;		/* 服务名 */
	char **s_aliases;	/* 别名列表 */
	int s_port;		/* 端口号，网络序存放 */
	char *s_proto;		/* 使用的协议列表 */
};
一般同一端口号TCP和UDP用于同一服务，但也有例外，所以不能以此作为定理。

---------------------------------------
References:
UNP Chapter 9 基本名字与地址转换
