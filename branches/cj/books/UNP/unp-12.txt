Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

守护进程：在后台运行不受终端控制的进程
启动守护进程的多种方法：
    1.  从位于/etc/rc*目录下的系统启动脚本启动
    2.  许多网络服务器从inetd超级服务器启动，inetd监听网络请求，当请求到来时启
        动实际的服务器。
    3.  cron守护进程按规则定期执行一些程序，由它启动的程序也以守护进程的方式运行
    4.  可用at命令指定在将来某一时刻执行程序，到时cron守护进程会启动这些程序
    5.  从用户终端上启动

守护进程如何输出信息？
标准方式是将消息通过syslog函数发往syslogd守护进程。
访问syslog有几种方法，一种是通过创建一个UNIX域套接口，向syslogd守护进程绑定的
路径名（/dev/log）发送消息；一种是通过UDP套接口，端口514发送消息（目前默认不打
开此UDP端口）；一种是通过设备/dev/klog访问。

#include <syslog.h>
void syslog(int priority, const char *message, ...);
参数priority是级别（level）和设施（facility）的或运算组合，message的格式化字符
串类似printf，还增加了%m，它对应当前errno值得出错消息，消息结尾的换行符不是必
须的。设施和级别的目的是为了允许在/etc/syslog.conf中进行配置，使得对相同设施或
相同级别的消息得到同样的处理。
级别缺省为LOG_NOTICE，设施默认为LOG_USER。

syslog过程，当用户第一次调用syslog时，它创建一个UNIX数据报套接口，然后调用
connect连接其路径，在进城终止前这个套接口一直打开。另外，进程也可以调用openlog
和closelog；

#include <syslog.h>
void openlog(const char *ident, int options, int facility);
void closelog(void);
openlog可在第一次调用syslog前调用，ident是一个字符串，它将被加到每条登记消息前
面，通常为程序名。options为多个常值得位或。通常调用openlog是并不创建UNIX套接口，
而是在第一次调用syslog时打开的。
可在shell脚本中调用logger命令产生日志消息。

创建守护进程
（1）fork()父进程推出，shell会认为命令已完成，子进程在后台运行，子进程继承了父
进程的进程组号，但又自己的进程号，这保证了子进程不是进程组头，这是下一步调用
setsid必需的；（2）调用setsid，它创建一个新的登录会话（session），这个进程变为
新会话的会话头和新进程组的组长，不再有控制终端；（3）然后忽略SIGHUP信号，再次
fork，当这个函数返回时，新生成的子进程就是守护进程了，再次fork的目的是为了确保
守护进程将来即使打开一个终端设备，也不会自动获得控制终端。
小结过程：fork()，父进程退出；子进程调用setsid（）；忽略SIGHUP信号，再次fork()；
改变工作目录，关闭所有打开的文件描述字（比如关闭前64个），用syslogd处理错误。

为什么要有inetd守护进程？ 
假如为每个服务创建一个对应进程的话有如下问题：
    它们的初始代码基本相同，都是创建套接口，绑定端口，等待连接或数据报，然后
    fork()，还可能每个都要初始化为守护进程；此外每个守护进程都在进程表中占据
    一项，但大部分时间它们在休眠。
利用inetd超级服务器来处理大部分的启动工作。

inetd工作流程：
启动时读取/etc/inetd.conf文件，并给文件中指定的所有服务创建一个相应类型的套接
口（字节流或数据报）。每个新创建的套接口都被加入到select调用所用到的描述字集
中；为每个套接口调用bind，给它们捆绑服务器的众所周知端口和通配地址；对TCP端口
调用listen，以接收外来的连接请求；调用select等待这些套接口变为可读，select调用
阻塞；select返回一个可读的套接口后，如果是TCP套接口，就调用accept接受这个新的
连接；inet守护进程fork，由子进程处理服务请求；子进程关闭除要处理的套接口描述字
外的所有描述字；子进程三次调用dup2，把套接口描述字复制到描述字0、1、2，然后关闭
原描述字；子进程调用getpwnam得到配置文件中指定的login-name对应的项，如果用户不
是root，子进程调用setgid和setuid变为该用户；子进程调用exec执行相应的服务器处理
请求，并将配置文件中指定的参数传递给它；如果是一个字节流套接口，父进程必须关闭
已连接套接口，父进程再调用select已等待下一个变成可读的套接口。


进程组：每个进程除了有一个进程ID，还属于一个进程组。进程组是一个或多个进程的集
合。通常它们与同一作业相关联，可以接收来自同一终端的信号。每个进程组有一个类型
为pid_t的进程组号，每个进程可有（不是必须）一个进程组头进程，其进程号等于进程
组号。进程组生存期为被创建直到最后一个进程离开（终止或转出）。一个进程只可以给
自己和子进程设置进程组号，而子进程调用exec后，父进程就无法再给它设置了。

会话：会话是一个或多个进程组的集合，会话头进程为创建会话的进程，一个不是进程组
头进程的进程如果调用setsid创建一个会话，它会变为会话头进程和新进程组的头进程，
且这个进程不再有控制终端，如果该进程已经是一个进程组的组长则创建会失败。
为了防止setsid失败，通常会fork后退出父进程，由子进程（非进程组头进程）来调用
setsid()创建会话。

---------------------------------------
References:
UNP Chapter 12 守护进程和inetd超级服务器

