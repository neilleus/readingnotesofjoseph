Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

*** VFS基本概念
VFS是建立在底层文件系统接口上的一个抽象层，VFS提供了一个通用文件系统模型，该模型
包括了所有文件系统的常用功能和行为。实际文件系统实现VFS所期望的接口和数据结构。

*** UNIX文件系统概念
UNIX使用了四种和文件系统相关的传统抽象概念：文件 目录项 索引节点 挂载点
UNIX文件系统采用面向字节流的抽象（简单），还有面向记录的文件系统。
UNIX区分文件的相关信息（也叫元数据，如权限、大小、时间等）和文件本身（数据）。
元素据存储在一个单独的数据机构中，该结构被称为索引节点（inode）。
文件系统的控制信息存储在超级块中，超级块是一种包含文件系统信息的数据结构。
目录也是文件，目录的内容是目录项。

VFS的设计目标就是要保证能与支持和实现了上述UNIX文件系统概念的文件系统协同工作。
非UNIX类的文件系统要想工作就需要进行封装，提供一个符合上述概念的界面，比如有些
文件系统不支持索引节点，有些将目录看作一种特殊对象，都要进行转换，通常在转换是
在现场（on the fly）发生的。

*** VFS的实现
VFS中有四个主要的对象类型，每个对象都包含一个操作对象（ops），许多操作对象中的
方法可以继承使用VFS提供的通用函数。
  +--------------+------------------+--------------------+
  | 对象类型     | 操作对象         | 所描述的对象       |
  +--------------+------------------+--------------------+
  | 超级块对象   | super_operations | 已安装的文件系统   |
  +--------------+------------------+--------------------+
  | 索引节点对象 | inode_operations | 一个文件           |
  +--------------+------------------+--------------------+
  | 目录项对象   | dentry_operations| 一个目录项         |
  +--------------+------------------+--------------------+
  | 文件对象     | file_operations  | 由进程打开的文件   |
  +--------------+------------------+--------------------+
此外还有其它许多结构体对象。

*** 超级块对象
各种文件系统都必须实现超级块，用于存储特定文件系统的信息，通常对应于存放在磁盘
特定扇区中的文件系统超级块或文件系统控制块。对于不是基于磁盘的文件系统，会在现
场创建超级块并保存到内存中。
struct super_block{...s_op...};		linux/fs.h	fs/super.c
struct super_operations{};		linux/fs.h
alloc_super();		创建并初始化超级块对象
文件系统超级块的操作函数在进程上下文中调用，它们都可以阻塞。

*** 索引节点对象
该对象包含了内核在操作文件或目录时需要的全部信息。UNIX类文件系统，这些信息可从
磁盘索引节点直接读入，如果是没有索引节点的文件系统。
struct inode{...i_op...};		linux/fs.h
struct inode_operations{};		linux/fs.h

*** 目录项对象
目录也是文件，但为了方便查找操作，VFS引入了目录项的概念，每个dentry代表路径中
的一个特定部分。比如/usr/bin/ls中/，usr，bin，ls都是目录项对象，前三个为目录文
件，最后一个为普通文件。不同于超级块对象和索引节点对象，目录项对象没有对应的磁
盘数据结构，VFS根据字符串形式的路径名现场创建它。
目录项对象有三种有效状态：被使用，未被使用，负状态。
struct dentry {...d_op...};		linux/dcache.h

*** 文件对象
它代表进程以打开的文件，是已打开文件在内存中的表示，进程直接处理的是文件。
该对象由相应的open()系统调用创建，由close()系统调用销毁。
由于多个进程可以同时打开和操作同一个文件，所以同一个文件可能存在多个对应的文件
对象。
文件对象也没有对应的磁盘数据，所以结构体中没有代表对象脏和的成员和是否需要写回
磁盘的标志。
struct file{...f_op...};		linux/fs.h
struct file_operations{};

*** 其它文件系统数据结构
struct file_system_type{};		描述特定文件的功能和行为
struct vfsmount{};			代表文件系统的实例，即代表一个安装点

*** 和进程相关的数据结构
struct files_struct{};		linux/file.h 代表进程打开的所有文件。
struct fs_struct{};		linux/fs_struct.h 包含文件系统和进程相关信息
struct namespace{};		linux/namespace.h ???

*** 字符设备和块设备的区别
根本区别：能否随机访问，按块方式还是字符流方式
块设备  ：随机无序访问固定大小的块，通常安装文件系统
字符设备：字符流方式有序访问
内核为服务块设备提供了一个专门的子系统，而字符设备则不需要。

*** 块设备基本概念
基于扇区（sector）来访问物理磁盘，基于块（block）来访问文件系统。
扇区一般是2的n次方大小，典型为512B，内核要求块也是2的n次方大小，且块大小通常为
扇区大小的整数倍，并且块大小要小于页面大小，典型大小为512B，1K或4K。

*** 缓冲区和缓冲区头
当一个块被调入内存时，它要存储在一个缓冲区中，每个缓冲区与一个块对应，相当于磁
盘块在内存中的表示。而一个缓冲区的控制信息由一个描述符来对应表示，用buffer_head
来描述，即缓冲区头。缓冲区头的目的在于描述磁盘块和物理内存缓冲区之间的映射关系。
struct buffer_head{};			linux/buffer_head.h
缓冲区头的弊病和新的继任者bio。

*** bio结构体
struct bio{};				linux/bio.h
它是内核中块IO操作的基本容器，代表了正在现场的（活动的）以片段（segment）链表
形式组织的块IO操作。一个片断式一小块连续的内存缓冲区，不需要保证单个缓冲区一定
要连续，即使一个缓冲区分散在内存的多个位置上，bio结构体也能够对内核保证IO操作的
执行，这样的向量IO就是聚散IO。
结构体中的几个重要域
	bi_io_vecs	指向一个bio_vec结构体数组，代表某IO需要的所有片段
	bi_vcnt		表示片段的数量
	bi_idx		表示当前的片段的索引

*** 请求队列和请求
块设备将它们挂起的IO请求保存在请求队列中，该队列由request_queue结构体表示，队
列中的请求由结构request表示，它们定义于<linux/blkdev.h>中。

*** 性能优化：IO调度程序
由于磁盘请求很慢，所以在向块设备提交请求前内核会先执行合并和排序预操作。内核中
由IO调度程序子系统来负责提交IO请求。IO调度程序将磁盘资源分配给系统中所有挂起的
块IO请求，其工作是管理块设备的请求队列，决定队列中的请求的排列顺序以及什么时候
派发请求到设备。合并将多个请求结合成一个新请求。IO调度程序尽量保证磁盘头以直线
方向移动，类似电梯调度。
Linus电梯，当一个请求加入队列时，可能发生四种操作，分别是：
	合并
	为防止饿死其它请求而加入到队列尾部
	插入到某个有序的位置
	找不到合适位置而加入到队列尾部

Linus电梯会导致某些请求饿死，所以引入了最终期限IO调度程序
最终期限IO调度程序会降低全局吞吐量，为此引入了预测IO调度程序。
完全公正的排队IO调度程序
空操作的IO调度程序

调度程序的选择，可以通过内核的命令行选项elevator=name来指定，默认为预测IO调度。
  +----------------+-----------------+
  |IO调度程序名称  |  命令行参数     |
  +----------------+-----------------+
  |预测IO          |  as             |
  +----------------+-----------------+
  |完全公正的排队  |  cfq            |
  +----------------+-----------------+
  |最终期限        |  deadline       |
  +----------------+-----------------+
  |空操作          |  noop           |
  +----------------+-----------------+

*** 小知识
C语言面向对象时与C++，JAVA等的一个不同：
由于C语言缺少对面向对象的支持，类似object->ops->do_something(object);加入是面向
对象的语言可以不必将操作对象通过参数传入，而C语言则需要这样做。C中无法直接得到
操作对象的父对象，所以必须将父对象以参数形式传给操作函数。

---------------------------------------
References:
Linux Kernel Development Chapter 12 虚拟文件系统
Linux Kernel Development Chapter 13 块I/O层

