Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

异常和中断有什么不同?
异常产生时必须考虑与处理器时钟同步。
一般常用的异常：缺页异常，指令异常等，产生异常时需要陷入内核，由内核来处理。

中断处理程序，上半部和下半部
为了快速进行中断处理，将中断处理过程分成上半部和下半部，上半部一般在关中断的情
况下执行，而下半部则在开中断的情况下执行。Linux中狭义的中断处理函数即是中断处理
的上半部。

中断处理程序原型：
    static irqreturn_t intr_handler(int irq, void *dev_id,
				    struct pt_regs *regs);
    返回值有两种IRQ_NONE和IRQ_HANDLED

关于中断处理程序的重入：
    中断处理程序是无需重入的。在处理中断的时候，当前中断对于所有处理器来说都是
    关闭的，也就是说即使在SMP的情况下同一中断也不会嵌套。

关于共享的中断处理程序
    指共享同一中断号的中断处理程序。要求硬件和软件配合需要能够获得是否是它的设
    备产生的中断，注册时需要指定SA_SHIRQ标志，另外对每个共享中断处理程序其
    dev_id参数必须唯一，而不可以是NULL。

关于中断上下文
    中断上下文不要睡眠（不要调用会睡眠的函数）。中断上下文尽量简洁快速。

关于中断处理程序栈
    这是一个配置选项，如果不配置，则中断处理程序共享所中断进程的堆栈，内核栈的
    大小是两页。如果配置了该选项，则原来的两页栈分出一页来交给中断处理程序使用。

内核的中断处理机制
    大部分代码体系结构相关。（略，参见另外的文档）

操作方法：
    注册中断处理函数：
        request_irq();
    卸载中断处理函数
    	free_irq();
    禁止或激活中断
    	local_irq_disable();
	local_irq_enable();
	local_irq_save(flags);
	local_irq_restore(flags);
    禁止指定中断
    	disable_irq();		等待指定中断处理程序执行完毕才返回
	disable_irq_nosync();	不等待
	enable_irq();		不等待
	synchronize_irq();	等待指定中断处理程序执行完毕才返回
    状态查询函数
        irqs_disable();		查看本地处理器的中断是否被禁止
	in_interrupt();		判断是否处于中断上下文或者下半部
	int_irq();		判断内核是否处于中断上下文

******************************************************************************
什么是下半部？
什么是软中断？
什么是tasklet？
什么是工作队列？

---------------------------------------
References:
Linux Kernel Development Chapter 6 中断和中断处理程序
Linux Kernel Development Chapter 7 下半部和推后执行的工作

