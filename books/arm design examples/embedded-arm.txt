Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

*******************************************************************************
关于开发工具和调试
*******************************************************************************
关于硬件调试
    工具箱：万用表，示波器，电烙铁等
    调试方法，注意模块化
        1) 一般从电源供电部分开始，最好单独调试这一块，比如有可能的话切断对后
	端负载的供电，保证各路供电电压正常，然后用示波器测试各路供电电压的纹
	波，一般在50mV以内都算正常。
	2) 然后接上负载，测量各处晶振的工作情况。无源晶振一般波形近于正弦波，
	有源晶振多近于方波。
	3) 调试最小系统，确保JTAG部分的连接正确，测量Flash和SDRAM上的时钟信号，
	执行Reset操作测量CPU的Reset信号。如果工作正确，使用适当软件可以烧写Boot
	Loader了。Boot Loader启动以后就可以通过某个特定外设来烧写文件系统和内
	核了。
	4) 根据具体应用对各外围子系统分别进行调试。
	5) 整体调试
    这是学究式的教条式做法，具体实践中可以灵活变通，实用为王。

工具箱
    开发板（通常必须）
    硬件仿真器（可选）
    下载调试工具（JTAG）（必须）
    开发编译环境（必须）
        编译器arm-linux-gcc
	汇编器arm-linux-as
	链接器arm-linux-ld
	库管理arm-linux-ar
	版本管理 CVS, SVN, GIT等

LDS链接脚本，Makefile等（略）


*******************************************************************************
关于启动
*******************************************************************************
Boot过程，一般包括
    大小端配置，ARM一般默认为小端格式，但是可以配置为大端格式。一般在上电时确定
    外围内存接口配置，通常对Flash的初始化代码一般都位于bootloader里
    启动模式选择，一般是通过硬件连线来确定的，比如从哪个位置以16位还是32位启动
    内存地址重映射，主要是由于异常向量入口需要重映射。
关于内存重映射
    CPU设计人员为了简化芯片设计，一般将所有异常入口集中放置在非易失性存储器中，
    并在系统上电时将其映射到一个固定的连续地址空间上。由于读取非易失性存储器的
    速度限制以及可能的位宽不匹配问题引入的性能问题，所以引入了重映射技术。就是
    对已经确立的存储器映射再次修改，即重新分配地址资源。MAP发生在系统上电的时
    候，REMAP则在系统上电稳定后发生，并且REMAP并不是必须的。
    REMAP一般开始于系统的Boot Loader，一般是Boot Loader将非易失性存储器中的异常
    向量复制到主存中，然后执行REMAP命令，将位于主存的异常向量块映射到以称向量表
    地址空间上。这样以后系统产生的异常处理将从主存中开始执行。


*******************************************************************************
关于Boot Loader
*******************************************************************************
一般基于ARM处理器的Linux嵌入式开发，基本都是硬件板卡设计和软件系统设计同步进行。
硬件准备好之后，首先要将Boot Loader，内核，文件系统等移植到硬件系统上。最先一步
就是要移植Boot Loader先启动系统。

Boot Loader的主要工作：初始化板上硬件，收集硬件资源信息以提供给操作系统，引导、
加载操作系统。

常用Boot Loader，可以参见wikipedia上关于它的介绍，要选择适用于嵌入式系统的。
http://en.wikipedia.org/wiki/Comparison_of_boot_loaders
这里只介绍U-Boot，目前该项目位于：
http://www.denx.de/wiki/U-Boot/

*******************************************************************************
关于U-Boot
*******************************************************************************
Universal Boot Loader，历史渊源可以去看它的网站上的介绍。最大特点在于对众多处理
器架构的支持。
U-Boot提供两种模式，启动加载模式（boot loading）和下载模式（downloading）。
U-Boot提供了大量功能，包括以太网支持，BOOTP/TFTP，在线读写FLASH等外设，串口支
持，识别多种二进制格式（ELF32，pImage等），脚本支持，监控等。

U-Boot常用命令
    1) 打印环境变量, printenv
    2) 设置环境变量, setenv
    3) 保存环境变量, saveenv
    4) 通过串口下载, loadb
    5) tftp网络下载，一般要先设置网络环境，然后通过网络下载映像文件到特定位置
    		U-boot> setenv ethaddr xx:xx:xx:xx:xx:xx
		U-boot> setenv ipaddr xx.xx.xx.xx
		U-boot> setenv serverip xx.xx.xx.xx (tftp server address)
		U-boot> tftp xxxxxxxx kernel.bin
    6) 内存操作命令：md, mm, nm, mw, cp, cmp, mtest
    7) 闪存操作命令：protect, erase, flinfo
    8) 文件系统命令：fatls, fatload, nfs
    9) 脚本: run, bootcmd
    a) CPU控制命令：go, bootm, bootp, kgo
    b) 其他命令：usb, help, ?, ping

一般Boot loader的工作流程
    1) 系统复位
    2) 从复位向量地址开始执行，通常是某cpu下面的Start.S汇编代码。这里完成定义
    异常向量表（需要关中断），初始化SDRAM，配置CPU模式，初始化工作时钟等
    3) 把启动代码复制到RAM中，然后进行地址重映射，然后开始执行启动例程（一般用
    C编写），这里初始化各种将要用到板上外设。

移植U-Boot主要是针对特定板子的移植，包括闪存、内存配置，串口配置等。如果有需要
在boot阶段需要启动的特殊硬件模块，那么需要自行添加对应的驱动支持。具体来说一般
需要移植如下几块：
    CPU初始化部分，包括工作频率，时钟模块，大小端配置，Cache初始化
    内存（SDRAM和FLASH）初始化，对应的接口寄存器设置各个参数，Flash初始化
    常用必备外设接口初始化：串口、网卡接口、GPIO接口等
    启动参数修改
    链接编译的地址分配，主要在.lds文件中
    编译参数的修改，主要修改Makefile文件

U-Boot启动执行的顺序是start.S -> board.c -> main.c
可能需要修改的文件包括start.S, mem_setup.S, flash.c, board.c cpu.c makefile,
	armboot.lds等
start.S开始的地方存放中断向量表，最重要的是reset服务程序，即CPU复位后最开始执
行的程序。主要完成系统初始化（时钟，中断控制）；内存访问初始化；转到supervisor
模式，将ARMBoot复制到SDRAM，并重新映射地址。
cpu.c主要完成CPU的初始化，包括Cache的初始化，开中断，软件复位等。
interrupt.c中主要完成中断全局控制函数的定义
config.mk文件
u-boot.lds文件，LDS文件是ld链接器的脚本文件，器中规定了程序入口，各个段的放置
位置信息等，ld脚本的书写方法可以在ld.info::Scripts::中找到。

编译U-Boot过程（在板子已经支持的情况下）
    设置交叉编译器
	$CROSS_COMPILE=arm_linux-
	$export CROSS_COMPILE
    选定特定的板子的配置
	$make NAME_config
    开始编译
	$make all
    得到二进制映像
	u-boot.bin	这是一个未修改的二进制映像
	u-boot		这是一个ELF格式的二进制映像
	u-boot.srec	这是一个摩托罗拉 S-Record格式的映像

移植U-Boot的过程（在板子列表里尚未支持）
    1. 在最上层Makefile和MAKEALL中按照已有的例子为你的板子增加一个配置选项。注
    意按字母顺序排列。
    2. 创建一个目录存放你的板子相关代码，至少需要Makefile, <board>.c, flash.c
    和u-boot.lds
    3. 为你的板子创建一个新的板子配置文件include/configs/<board>.h
       如果是向一个新的CPU移植，那么还需要创建一个CPU相关代码的目录。
    4. 运行make <board>_config
    5. 运行make，然后得到一个u-boot.srec文件
    6. 运行调试

镜像格式
    U-boot可以以两种格式启动
    新的uImage格式（FIT）
    老的uImage格式

*******************************************************************************
关于裸机驱动开发（类似单片机的开发）
*******************************************************************************
关于ARM汇编伪指令
    伪指令，某些指令助记符没有对应的CPU指令。通常伪指令的作用是为完成汇编程序
    做各种准备工作。这些指令仅在汇编过程中起作用。
        符号定义，用于定义汇编程序的变量，对变量进行赋值，定义寄存器名称等操作
	有全局和局部之分
	    GBLA, GBLL, GBLS, LCLA, CN, CP, DN, FN, RLIST, SETA...
	数据定义，用于数据表定义，文字池定义，数据空间分配等。常用DCB/Q/W分配一
	段内存并将其初始化
	    LTORG, MAP, DCB, FIELD, SPACE, DCQ, DCW...
	报告伪操作符，用于汇编报告，常用ASSERT报告断言错误
	    ASSERT, INFO, OPT...
	条件汇编伪操作符，用于条件汇编，宏定义，循环控制等
	    IF, ELSE, ENDIF, WHIL, WEND, MACRO, MEND...
	其他，段定义，入口点设置等
	    AREA	用来定义段
	    ALIGN	用来设定边界对齐
	    ENTRY	指定程序入口
	    CODE16/CODE32	指定指令集
	    END		汇编结束
	    EQU, EXPORT, GLOBAL, IMPORT...

关于模块化汇编语言程序设计
    要注意：全局符号的定义和引用，各个模块间符号的互相调用方法等
    关于全局符号：定义.global xxx  声明.extern xxx
    模块间符号调用，也包括汇编和C的混合调用，包括函数和变量，C语言中要做声明，
    而且必须要求是全局的。
混合语言编程
    一般程序的初始化部分用汇编语言来完成，主要
