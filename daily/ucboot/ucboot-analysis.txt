*** Flash

硬件层：chips（我们用CFI）
MTD原始设备：mtd_info, mtd_part
MTD设备，有主次设备号


即每块闪存芯片对应一个flash_info数据结构，u-boot通过该结构来管理闪存信息。
需要保护的内容：monitor区，环境变量区，备份环境变量区

数据结构：
/* 表示闪存芯片信息的数据结构 */
typedef struct{
	ulong	size;			/* 单位：字节 */
	ushort	sector_count;
	ulong	flash_id;		/* device id和manufacture id的组合 */
	ulong	start[MAX_FLASH_SECT];
	uchar	protect[MAX_FLASH_SECT];
#ifdef CONFIG_MTD_CFI
	uchar	portwidth;
	uchar	chipwidth;		/* 闪存实际已连接的数据总线宽度 */
	ushort	buffer_size;
	ulong	erase_blk_tout;
	ulong	write_tout;
	ulong	buffer_write_tout;
	ushort	vendor;			/* 主算法id */
	ushort	cmd_reset;		/* 复位命令码 */
	ushort	interface;		/* QUERY中给出的闪存数据总线宽度 */
	ushort	legacy_unlock;
	uchar	manufacture_id;
	ushort	device_id;
	ushort	device_id2;		/* 扩展设备id */
	ushort	ext_addr;		/* 扩展查询表地址 */
	ushort	cfi_version;
	ushort	cfi_offset;		/* cfi QEERY的偏移地址 */
	ulong	addr_unlock1;
	ulong	addr_unlock2;
	const char *name;
#endif
} flash_info_t;

struct cfi_qry{
	u8	qry[3];			/* 'Q' 'R' 'Y' */
	u16	p_id;			/* 主算法id */
	u16	p_adr;			/* 主算法表地址 */
	u16	a_id;
	u16	a_adr;
	...	;			/* 电气时序信息 */
	u8	dev_size;		/* 闪存大小为：2**dev_size字节 */
	u16	interface_desc;		/* x8-only, x8/x16, x16-only... */
	u16	max_buf_write_size;
	u8	num_erase_regions;	/* 擦除区种类数（分隔的同大小擦除块组
					   也算不同擦除区） */
	u32	erase_region_info[NUM_ERASE_REGIONS];
					/* 32字节分为两部分：
					 * 高16位z：擦除块大小为256*z字节
					 * 低16为y：同大小擦除块数量（y+1）
					 */
} __attribute__((packed));

void flash_protect(int flag, ulong from, ulong to, flash_info_t *info);
void flash_perror(int err);
int flash_write(char *src, ulong addr, ulong cnt);
    将内存的内容拷贝到Flash中，注意这里写的区域必须落在flash内，并且不能有写保
    护的区域。实现判断传入的地址是否合法，是否落在了写保护区域内。然后擦除要写
    的块，然后从addr所在块的起始写入，知道end所在块。擦除是按块擦除的。
flash_info_t *addr2info(ulong addr);
    遍历flash_info数组，查找addr是否位于某个flash_info指向的地址范围内，如果有
    返回该flash_info的地址。

/* cmd_flash.c */
static int abbrev_spec(char *str, flash_info_t **pinfo,
		       int *psf, int *psl);
static int addr_spec(char *arg1, char *arg2
		     ulong *addr_first, ulong *addr_last);
static int flash_fill_sect_ranges(ulong addr_first, ulong addr_last,
				  int *s_first, int *s_last, int *s_count);
int flash_sect_erase(ulong addr_first, ulong addr_last);
int flash_sect_protect(int p, ulong addr_first, ulong addr_last);
int do_flerase(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
int do_flinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
    打印指定或者全部bank的flash的信息，包括厂商型号，大小，块数信息以及每块的
    起始地址和保护位的设置情况。
int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
    设置指定块或者全部块或者指定地址范围的保护标记。

portwidth的变化：在执行CFI QUERY命令时portwidth为16bit，在调用flash_get_size时
会将其该位8bit，这会影响flash_write_cmd()和flash_map()，注意考虑。

MAX_FLASH_BANKS_DETECT
    动态配置
    用来分配足够可能的空间供flash_info使用，确定的flash bank数量在运行时确定。
    运行时通过detect_num_flash_banks()将bank数量存放到一个变量中

### Memory technology device
数据结构:
struct mtd_info {
 *      u_char		type;
 *      uint32_t	flags;		/* 设备可写，位可写，不需擦除，自动锁 */
 *      uint64_t	size
 *      uint32_t	erasesize;
 *      uint32_t	writesize;

        uint32_t	oobsize;	/* Out-of-Band */
        uint32_t	oobavail;

        /* kernel-only stuff */
 *      const char	*name;
 *      int		index;		/* 多个mtd设备时的索引号 */

        struct nand_ecclayout	*ecclayout;
 *      int		numeraseregions;
 *      struct mtd_erase_region_info	*eraseregions;

        /* 闪存操作方法 */
 *      int (*erase)();
        int (*point)();		/* 返回指向指定闪存位置的指针并锁定闪存 */
        void (*unpoint)();	/* 解锁 */
 *      int (*read)();
 *      int (*write)();
        int (*panic_write)();	/* 内核可能panic时采用的写操作 */
        int (*read_oob)();
        int (*write_oob)();

        /* 以下是和闪存保护相关的几个方法 */
        int (*get_fact_prot_info)();
        int (*read_fact_prot_reg)();
        int (*get_user_prot_info)();
        int (*read_user_prot_reg)();
        int (*write_user_prot_reg)();
        int (*lock_user_prot_reg)();

 *      void (*sync)();
 *      int (*lock)();
 *      int (*unlock)();

        /* Power Management */
        int (*suspend)();
        void (*resume)();
        /* Bad block manageme */
        int (*block_isbad)();
        int (*block_markbad)(); 

        /* ECC status information */
        struct mtd_ecc_stats ecc_stats;
        /* Subpage shift (NAND) */
        int subpage_sft;

 *      void *priv;		/* 指向map_info类型的对象 */

        struct module *owner;
        int usecount;

        int (*get_device) (struct mtd_info *mtd);
        void (*put_device) (struct mtd_info *mtd);
};

struct mtd_erase_region_info {
	uint64_t	offset;
	uint32_t	erasesize;
	uint32_t	numblocks;
	ungsigned long *lockmap;
};

struct mtd_partitions {
	char		*name;
	uint32_t	size;
	uint32_t	offset;
	uint32_t	mask_flags;

	struct nand_ecclayout	*ecclayout;
	struct mtd_info	**mtdp;
};

struct mtd_part {
	struct mtd_info	mtd;
	struct mtd_info *master;
	uint64_t	offset;
	int		index;
	struct list_head list;
	int		registered;
};

ioctls
int add_mtd_device(struct mtd_info *mtd);
int del_mtd_device(struct mtd_info *mtd);
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num);
struct mtd_info *get_mtd_device_nm(const char *name);
put_mtd_device(struct mtd_info *mtd);

int add_mtd_partitions(struct mtd_info *, const struct mtd_partition *, int);
int del_mtd_partitions(struct mtd_info *);

管理组织mtd device和mtd partition
struct mtd_info *mtd_table[MAX_MTD_DEVICES];	/* mtd设备管理指针数组 */
static struct mtd_info cfi_mtd_info[CFI_MAX_FLASH_bANKS]; /* cfi mtd设备信息 */
mtd设备管理指针指向这里的cfi mtd设备信息数组
cfi_mtd_init();	/* 初始化cfi_mtd_info内容 */

### jffs2
数据结构
struct mtd_device {
	struct list_head	link;
	struct mtdids 		*id;		/* parent mtd id entry */
	u16			num_parts;
	struct list_head	parts;
};

struct part_info {
	struct list_head	link;
	char			*name;
	u8			auto_name;	/* 1 for generated name */
	u32			size;
	u32			offset;		/* offset within device */
	void			*jffs2_priv;
	u32			mask_flags;	/* kernel MTD mask flags */
	u32			sector_size;
	struct mtd_device	*dev;
};

struct mtdids {
	struct list_head	link;
	u8			type;		/* device type */
	u8			num;		/* device number */
	u32			size;		/* device size */
	char			*mtd_id;	/* linux kernel device id */
};

方法



### dlmalloc 2.6.6, newest 2.8.4 Doug Lea's malloc
### ptmalloc: 	http://www.malloc.de/en/index.html
设计目标：
兼容性：ANSI/POSIX；可移植性：对齐和地址限制问题；最小空间：管理开销小，减少变
小碎片；时间要求：平均情况下尽可能快；最大本地分配：附近一起分配，减少页和缓存
的不命中；最大错误检测：提供检测存储器覆盖，多次释放等错误的方法和机制；最小异
常；
首要目的：减少由于碎片而造成的空间浪费。

实现算法：
两个基本元素：边界标签和Binning
可用的块由bins按照大小来组织，有很多（128个）固定宽度的bins。小于512字节的bins
每个仅包含一个，按8字节分开，为了增强8字节对齐的性能。查找可用块的处理是先从最
小块开始，找最合适的，最合适的是碎片最小的情况。
会有多个连续已分配的块，但不会有多个连续的未分配块。
一个已分配块包含前一块的大小，当前块的大小和当前块以及前块的状态信息，最后是分
配的内存。
宏next_chunk(p)和prev_chunk(p)可以获取指向前后块的指针。
结构中的fd, bk在块空闲时用于将空闲块加入到空闲块链表以便统一管理，如果块已分配
这两个指针就没有用了，这是它们作为可分配的内存返回。
块和返回的分配的内存地址转化宏：chunk2mem(p)和mem2chunk(mem)

参考了Knuth的边界标签来维护可分配内存块，在每个块的头部和尾端都存放块的大小信
息，这样可以方便的进行碎片整理，并且块头部还有块的状态信息（已分配或空闲），头
部之后为分配给用户的内存区域，指向这一区域的指针返回给用户。一个已分配块的形状
如下：
       chunk---->+-------------------+
    		 | sizeof(pre-chunk) |
                 +-------------------+----------+
    		 | sizeof(cur-chunk) |prev-inuse|
       mem------>+-------------------+----------+
    		 |    user memory    |
   next_chunk--->+-------------------+

块总是从偶数字地址上开始，所以返回给用户的内存地址也是从偶数字地址开始。即是
双字对齐的。
空闲块被保存在双向循环链表中，如下所示：
        chunk---->+-------------------+
 		  | sizeof(pre-chunk) |
                  +-------------------+----------+
 	head	  | sizeof(cur-chunk) |prev-inuse|
        mem------>+-------------------+----------+
		  | ptr->(next-chunk) |
                  +-------------------+
		  | ptr->(prev-chunk) |
                  +-------------------+
 		  |   unused memory   |
    next_chunk--->+-------------------+
 	foot	  | sizeof(cur-chunk) |
                  +-------------------+
prev-inuse位用来标记前面的块已被分配，可以方便回收，第一个被分配块的该位总是被
置位，以防止访问非法内存。
BIT


******************************************************************************
### 网络
star_gsw_router
star_gsw_eth_init:	注册为dev->init，由eth_init调用，它由NetLoop调用
star_gsw_initialize:	系统复位时调用，初始化硬件并注册设备
star_gsw_init:		在系统复位时会被initialize调用一次，进行内存和硬件初始
			化，如果初始化成功就会设置相应的标志位，后续就不会再调
			用，否则会由eth_init调用。

数据结构
TX_DESC_T
RX_DESC_T
pkt_t
pkt_t中有一个指针指向接收和发送的数据存放的内存位置。这几个数据结构通过
star_gsw_mem_init初始化，这个在系统复位的时候完成，不成功的话还会由eth_init调用


******************************************************************************
### 命令及自动完成
        
typedef struct cmd_tbl_s cmd_tbl_t;
命令保存在一个（数组）表中，通过链接时段收集作用收集到一起，表的边界为：
	__u_boot_cmd_start, ..., __u_boot_cmd_end
	它们定义在链接器脚本中。

所有命令处理函数有共同的格式如下：
	void function(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);

#define U_BOOT_CMD(name, maxargs, repeat, cmd, usage, long_help)	\
	cmd_tbl_t __u_boot_cmd##name Struct_Section = {...}

static char tmp_buf[MAX_CBSIZE];

int cmd_auto_complete(const char *const prompt, char *buf,
		      int *np, int *colp)
int cmd_get_data_size(char* arg, int default_size)
static int complete_cmdv(int argc, char *argv[], char last_char,
			 int maxv, char *cmdv[])
cmd_tbl_t *find_cmd (const char *cmd)
static int find_common_prefix(char *argv[])
void install_auto_complete(void)
static void install_auto_complete_handler(const char *cmd,
		int (*complete)(int argc, char *argv[], char last_char,
				int maxv, char *cmdv[]))
static int make_argv(char *s, int argvsz, char *argv[])
static void print_argv(const char *banner, const char *leader,
		       const char *sep, int linemax, char *argv[])
int var_complete(int argc, char *argv[], char last_char, int maxv, char *cmdv[])
int do_echo(cmd_tbl_t *cmdtp, int flag,
	    int argc, char *argv[])
int do_help (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
int do_version(cmd_tbl_t *cmdtp, int flag,


******************************************************************************
### 资料信息：
命令列表
CONFIG_NET_CMDLINE 
CONFIG_ENV_CMDLINE
CONFIG_FLASH_CMDLINE

CONFIG_LINUX_TAG_CMDLINE
CONFIG_SAVEENV_CMDLINE
CONFIG_CACHE_CMDLINE
CONFIG_LOADB_CMDLINE
CONFIG_BOOTD_CMDLINE
CONFIG_ASKENV_CMDLINE
CONFIG_NAND_CMDLINE
CONFIG_MII_CMDLINE
CONFIG_LOADB_CMDLINE

dcache
icache
bdinfo
flinfo
iminfo
coninfo
imls

bmp		?
echo
help/?

loadb
loads		?
go
run
cmp
cp		可否从dram到flash？
md
mw
protect
erase

reset
version

printenv
saveenv
setenv

boot
bootm
bootp
diskboot	?

rarpboot
tftpboot
ping
dhcp

闪存CFI信息
Flash Manufacturer/Device: 0x007f 0x00c9
#0 : cfi at 0x10000000, size 0x00800000, buswidth 1, chipwidth 1
cfi information:
manufacture-id: 0x007f, device-id:0x00c9
qry: 'QRY'
pri_id: 0x0002, pri_addr: 0x0040
alt_id: 0x0000, alt_addr: 0x0000
Vcc min: 2.7, Vcc max: 3.6
Vpp min: 0.0, Vpp max: 0.0
typ. word write timeout: 16
typ. buf write timeout: 1
typ. block erase timeout: 1024
typ. chip erase timeout: 1
max. word write timeout: 512
max. buf write timeout: 1
max. block erase timeout: 16384
max. chip erase timeout: 1
size: 0x800000
interface desc: 2
max buffer write size: 1

Spansion primary algorithm extend information:
pri: 'PRI', version: 1.1
Silicon Rev.: 0x0, Address Sensitive unlock: 0x0
Erase Suspend: 0x2, Sector Protect: 0x4
VppMin: 10.5, VppMax: 12.5


