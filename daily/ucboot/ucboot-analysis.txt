******************************************************************************
关于env
grocx为ucboot.bin设置了320KB的flash空间，env保存在0x10050000位置
更新env CRC的时机：env_valid失效，使用default时计算一次，setenv时会根据是（增
加/修改）还是删除各计算一次，env修改即是删除旧的，增加新的。
CONFIG_ENV_OVERWRITE		串口和MAC地址是否可以更改
CONFIG_OVERWRITE_ETHADDR_ONCE	MAC地址只可以更改一次，即未设置时初始设置一次。
CONFIG_ENV_FLASH		环境变量保存在FLASH中
CONFIG_ENV_NVRAM		环境变量保存在NVRAM中
CONFIG_ENV_NAND 		环境变量保存在NAND中，需要支持NAND
CONFIG_ENV_NOWHERE		环境变量不保存

CFG_ENV_ADDR			ENV的位置，应该位于某个sector的边界上。
				环境变量存放位置，如果该位置没有ENV，则读取镜
				像中的default env，saveenv的时候会把env存放到
				该位置

CFG_ENV_SIZE			ENV的大小（这里定义为FLASH的SECT大小）
CFG_ENV_OFFSET			ENV在FLASH上的偏移
CFG_ENV_SECT_SIZE		
CFG_ENV_ADDR_REDUND 		冗余备份位置
CFG_ENV_SIZE_REDUND		冗余备份大小
CFG_ENV_OFFSET_REDUND		冗余备份偏移
CFG_LOAD_ADDR			内核启动地址

CFG_REDUNDAND_ENVIRONMENT
ENV_SIZE			环境变量大小，不包括CRC校验和标志
ENV_IS_EMBEDDED			环境变量编译到二进制中
ENV_HEADER_SIZE			CRC校验和标志（当前还是备份）的大小

CONFIG_BOOTARGS
CONFIG_BOOTCOMMAND
CONFIG_RAMBOOTCOMMAND
CONFIG_NFSBOOTCOMMAND
CONFIG_BOOTDELAY
CONFIG_LOADS_ECHO
CONFIG_ETHADDR
CONFIG_ETH1ADDR
CONFIG_ETH2ADDR
CONFIG_ETH3ADDR
CONFIG_ETHPRIME
CONFIG_IPADDR
CONFIG_SERVERIP
CONFIG_ROOTPATH
CONFIG_GATEWAYIP
CONFIG_NETMASK
CONFIG_HOSTNAME
CONFIG_BOOTFILE
CONFIG_LOADADDR
CONFIG_PREBOOT
CONFIG_EXTRA_ENV_SETTINGS
CONFIG_AUTOLOAD
CFG_ENV_SECT_SIZE
CFG_CONSOLE_IS_IN_ENV
CFG_CONSOLE_ENV_OVERWRITE

CFG_ENV_SIZE和CFG_ENV_SECT_SIZE
如果CFG_ENV_SIZE小于CFG_ENV_SECT_SIZE的话，表示在同一个SECT上可能还存在其它数
据，由于flash擦写是整块sector来擦写的，在saveenv的时候会导致这里的其他数据被
擦除，所以要区分这两个，区分了怎么保证呢？

简单介绍
形如"name=value"的C风格字符串，保存在一个表中，该表以"\0"结尾。新项总是加在表
尾端，删除时剩下的表项会往前移动。修改值的话相当于删除旧表项再添加新表项。
environment数据结构中有一个32位的CRC校验码覆盖数据部分。

数据结构
uchar default_environment[];	在没有设置环境变量时使用缺省环境变量表
extern uchar environment[];	自定义的环境变量表
env_t environment = {ENV_CRC, 1, {""}};

char *env_name_spec;
typedef struct environment_s {
	unsigned long crc;		/* crc32 over data bytes */
	unsigned char flags;		/* active / obsolete */
	unsigned char data[ENV_SIZE];	/* data bytes */
} env_t;

char *env_name_spec = "Flash";
static env_t *flash_addr = (env_t *)CFG_ENV_ADDR;
    环境变量在闪存上的地址
env *env_ptr = (env_t *)CFG_ENV_ADDR;
gd->env_addr;

static env+t *flash_addr_new = (env_t *)CFG_ENV_ADDR_REDUND;
    冗余环境变量在闪存上的地址
static ulong end_addr = CFG_ENV_ADDR + CFG_ENV_SECT_SIZE - 1;
static ulong end_addr_new = CFG_ENV_ADDR_REDUND + CFG_ENV_SECT_SIZE - 1;
#define ACTIVE_FLAG 	1
#define OBSOLETE_FLAGS 	0

操作方法
int env_init(void);	主要通过计算CRC校验和设置env地址值和有效标志。
void env_crc_update(void);  更新env-ptr指向的crc。
uchar *env_get_addr(int index); 返回env中index位置的指针
int env_complete(char *var, int maxv, char *cmdv[], int bufsz, char *buf);
用于名令自动完成

void env_relocate(void);	将env重定位到ram中，如果不是使用缺省，调用spec
void env_relocate_spec(void);	将env从flash拷贝到内存中的位置。

uchar (*env_get_char)(int);	函数指针，用于获取指定的index对应的env值
uchar env_get_char_spec(int);	由各种存储介质实现
static uchar env_get_char_init(int);	调用spec或从default位置取env。
uchar env_get_char_memory(int index);	env重定位到内存后，使用它来获取env值，它直接从给定内存位置取出或者从default中取出。

static int envmatch(uchar *s1, int i2);
char *getenv(char *);
    在环境变量表中查找对应名字的环境变量并返回指向该环境变量字符串的指针
int getenv_r(char *name, char *buf, unsigned len);
    按照name查找环境变量，并把查到的结果填入传入的buf中，返回值表示查询到的长度
int saveenv(void);
void setenv(char *, char *);

int do_setenv(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
    设置ENV变量，调用_do_setenv实现
int _do_setenv(int flag, int argc, char *argv[]);
    设置ENV变量，只对RAM中的ENV拷贝操作。
int do_askenv(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
int do_printenv(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
int do_saveenv(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);


******************************************************************************
关于Flash
一个系统内可以有多个bank的flash，每bank的flash有多个sectors。擦写的单位是sector
对每个bank的flash都对应一个flash_info数据结构。
FLASH有哪些属性呢？厂家ID号，设备ID号，大小，块数
EON EN29LV640T，共有8个8KB块（用于顶端和底端引导，硬件决定，T为顶端引导，B为底
端引导），127个64KB块。支持单块保护和块组保护，支持单块擦除和整片擦除。时间参考
值：字写（8us），块擦除（500ms），整块擦除（64s）。
需要保护的内容：monitor区，环境变量区，冗余备份环境变量区
Grocx:
CFG_ENV_ADDR		FLASH_BASE+0x50000
CFG_ENV_OFFSET		0x50000
CFG_ENV_SIZE		0x10000
TEXT_BASE		0x23000000		defined in Makefile

KS8695:
CFG_ENV_ADDR		FLASH_BASE + 0x00020000
TEXT_BASE		0x00F00000		defined in Makefile
数据结构：
typedef struct {} flash_info_t;

flash.c
void flash_protect(int flag, ulong from, ulong to, flash_info_t *info);
void flash_perror(int err);
int flash_write(char *src, ulong addr, ulong cnt);
    将内存的内容拷贝到Flash中，注意这里写的区域必须落在flash内，并且不能有写保
    护的区域。实现判断传入的地址是否合法，是否落在了写保护区域内。然后擦除要写
    的块，然后从addr所在块的起始写入，知道end所在块。擦除是按块擦除的。
flash_info_t *addr2info(ulong addr);
    遍历flash_info数组，查找addr是否位于某个flash_info指向的地址范围内，如果有
    返回该flash_info的地址。

/* cmd_flash.c */
static int abbrev_spec(char *str, flash_info_t **pinfo,
		       int *psf, int *psl);
static int addr_spec(char *arg1, char *arg2
		     ulong *addr_first, ulong *addr_last);
static int flash_fill_sect_ranges(ulong addr_first, ulong addr_last,
				  int *s_first, int *s_last, int *s_count);
int flash_sect_erase(ulong addr_first, ulong addr_last);
int flash_sect_protect(int p, ulong addr_first, ulong addr_last);
int do_flerase(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
int do_flinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
    打印指定或者全部bank的flash的信息，包括厂商型号，大小，块数信息以及每块的
    起始地址和保护位的设置情况。
int do_protect(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
    设置指定块或者全部块或者指定地址范围的保护标记。

/grocx_flash.c/
flash_info_t flash_info[MAX_FLASH_BANKS];
int flash_erase(flash_info_t *info, int s_first, int s_last);
int write_buff(flash_info_t *info, uchar *src, ulong addr, ulong cnt);
static int write_byte(flash_info_t *info, ulong dest, uchar data);

static ulong flash_get_size(vu_long *addr, flash_info_t *info);
    向flash写命令获得厂家id，并打印厂家信息，获得设备ID，根据设备ID设置
    flash_info数据结构的各个字段，包括id，块数，大小，保护位置零，设置各个块
    的基地址，确定每个块是否被保护，最后复位到读模式。
unsigned long flash_init(void);
    flash初始化，把每个bank的flash_id设为FLASH_UNKNONW
void flash_print_info(flash_info_t *info);

CONFIG_FLASH_PROTECTION
    flash是否在硬件上支持块擦写保护

******************************************************************************
关于启动操作系统


******************************************************************************
关于命令以及命令的自动完成

typedef struct cmd_tbl_s cmd_tbl_t;
命令保存在一个（数组）表中，通过链接时段收集作用收集到一起，表的边界为：
	__u_boot_cmd_start, ..., __u_boot_cmd_end
	它们定义在链接器脚本中。

所有命令处理函数有共同的格式如下：
	void function(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);

#define U_BOOT_CMD(name, maxargs, repeat, cmd, usage, long_help)	\
	cmd_tbl_t __u_boot_cmd##name Struct_Section = {...}

static char tmp_buf[MAX_CBSIZE];

int cmd_auto_complete(const char *const prompt, char *buf,
		      int *np, int *colp)
int cmd_get_data_size(char* arg, int default_size)
static int complete_cmdv(int argc, char *argv[], char last_char,
			 int maxv, char *cmdv[])
cmd_tbl_t *find_cmd (const char *cmd)
static int find_common_prefix(char *argv[])
void install_auto_complete(void)
static void install_auto_complete_handler(const char *cmd,
		int (*complete)(int argc, char *argv[], char last_char,
				int maxv, char *cmdv[]))
static int make_argv(char *s, int argvsz, char *argv[])
static void print_argv(const char *banner, const char *leader,
		       const char *sep, int linemax, char *argv[])
int var_complete(int argc, char *argv[], char last_char, int maxv, char *cmdv[])
int do_echo(cmd_tbl_t *cmdtp, int flag,
	    int argc, char *argv[])
int do_help (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
int do_version(cmd_tbl_t *cmdtp, int flag,



******************************************************************************
关于jump table来自Wolfgang Denk的回复：
The "jump table provided by U-Boot exactly for this purpose" is the
list of functions exported through the "include/_exports.h" header
file.
Only these functions are available from standalone programs without
linking against any of the U-Boot provided libraries. If your program
links and runs fine using only these functions then you are free to
license your standalone application whatever you like; if you need to
link against any of the U-Boot libraries then you must release your
code under GPL.
上面的意思就是说：所谓jump table就是在include/_exports.h头文件中导出的函数的列
表。如果外部的独立软件仅仅调用了这些函数，那么它可以是任意License，如果它内部链
接了U-Boot的其它库函数，则必须以GPL方式发布。

*******************************************************************************
关于FLASH和存储器以及Monitor
MAX_FLASH_BANKS_DETECT
    动态配置
    用来分配足够可能的空间供flash_info使用，确定的flash bank数量在运行时确定。
    运行时通过detect_num_flash_banks()将bank数量存放到一个变量中
*******************************************************************************
关于命令集
CONFIG_COMMANDS
CONFIG_AUTOCOMPLETE	根据环境变量来进行自动补全
    			删除这个配置，始终支持自动补全功能

*******************************************************************************
关于AUTOBOOT的配置
两个功能：可以停止进入U-BOOT命令行，可以自定义超时重试功能和超时时间，可以自定
义停止自动启动字符串和提示信息，可以自定义重试方式（是否重启）

为什么autoboot要用特殊的字符串？
因为如果使用任意键停止的话，可能在启动的时候，串口由于电平扰动，发送乱码，然后
导致U-boot停止，系统无法启动，在嵌入式设备上这毫无征兆。
参考文档README.autoboot

有关的CONFIG
    CONFIG_BOOT_RETRY_TIME
    CONFIG_BOOT_RETRY_MIN
    在U-Boot命令行无输入一定时间之后自动重试AUTOBOOT，如果CONFIG值为负，表示不
    重试，要支持重试，第一个CONFIG必须定义。参见bootretry
    CONFIG_AUTOBOOT_KEYED
    CONFIG_AUTOBOOT_PROMPT
    CONFIG_AUTOBOOT_DELAY_STR
    CONFIG_AUTOBOOT_STOP_STR
    CONFIG_AUTOBOOT_DELAY_STR2
    CONFIG_AUTOBOOT_STOP_STR2
	用来停止AUTOBOOT的相关配置项，可以指定特定字符或者字符串。
	CONFIG_AUTOBOOT_KEYED用来启用自定义停止符号这组配置，这时必须指定
	CONFIG_AUTOBOOT_DELAY_STR和CONFIG_AUTOBOOT_STOP_STR否则无法停止自动启动
	CONFIG_AUTOBOOT_PROMPT用来提示正在自动启动，不定义则没有提示。
	如果用DELAY_STR停止自动启动，则命令行超时后会重试自动启动
	如果用STOP_STR停止自动启动，则不会再进行重试，即使超时。
	STR2表示需要输入第二个字符串，主要用在输入密码这种应用中。
    CONFIG_ZERO_BOOTDELAY_CHECK
	设置这个选项，即使bootdelay设为0，也可以通过按键来停止自动启动
    CONFIG_RESET_TO_RETRY
	自动启动重试会采取重启系统的方式
有关的环境变量
    bootdelay
    bootretry
    bootdelaykey
    bootdelaykey2
    bootstopkey
    bootstopkey2

更改情况：
    删除 CONFIG_AUTOBOOT_XXX
    删除 CONFIG_BOOT_RETRY_MIN
    删除 CONFIG_ZERO_BOOTDELAY_CHECK
    删除 CONFIG_RESET_TO_RETRY
    更改 CONFIG_BOOT_RETRY_TIME为始终配置，负数表示不重试


*******************************************************************************
关于终端
CFG_CONSOLE_OVERWRITE_ROUTINE	是否定义了overwrite_console函数，如果定义了就使
用串口，如果没有定义就使用环境变量值。

CFG_CONSOLE_IS_IN_ENV	如果定义了表示，环境变量中定义了stdin, stdout, stderr
三个环境变量

CFG_CONSOLE_INFO_QUIET	是否在启动U-Boot的时候打印终端的配置信息，无用，删除
CONFIG_SPLASH_SCREEN	
	压缩显示内容为一张预先准备好的bmp图片，终端设备配置为nulldev。
CONFIG_SILENT_CONSOLE
	禁止自动启动时终端的输出，调用console_init_f()设置全局gd的flag，然后根
	据它，通过将std_devices[]设为nulldev,	如果自动启动过程被终止，终端会
	被重新设置为串口。


*******************************************************************************
关于命令列表
已定义
CONFIG_NET_CMDLINE 
CONFIG_ENV_CMDLINE
CONFIG_FLASH_CMDLINE

CONFIG_LINUX_TAG_CMDLINE
CONFIG_SAVEENV_CMDLINE
CONFIG_CACHE_CMDLINE
CONFIG_LOADB_CMDLINE
CONFIG_BOOTD_CMDLINE
CONFIG_ASKENV_CMDLINE
CONFIG_NAND_CMDLINE
CONFIG_MII_CMDLINE
CONFIG_LOADB_CMDLINE

dcache
icache
bdinfo
flinfo
iminfo
coninfo
imls

bmp		?
echo
help/?

loadb
loads		?
go
run
cmp
cp		可否从dram到flash？
md
mw
protect
erase

reset
version

printenv
saveenv
setenv

boot
bootm
bootp
diskboot	?

rarpboot
tftpboot
ping
dhcp

