******************************************************************************
关于初始化
U-boot ARM926EJS relocate和设置栈的过程
relocate:				/* relocate U-Boot to RAM */
	adr	r0, _start		/* r0 <- current position of code */
	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
	cmp	r0, r1			/* do't relocate during debug */
	beq	stack_setup

	ldr	r2, _armboot_start
	ldr	r3, _bss_start
	sub	r2, r3, r2		/* r2 <- size of armboot */
	add	r2, r0, r2		/* r2 <- source end address */

copy_loop:
	ldmia	r0!, (r3-r10)		/* copy from source address [r0] */
	stmia	r1!, (r3-r10)		/* copy to target address [r1] */
	cmp	r0, r2			/* until source end address [r2] */
	ble	copy_loop

stack_setup:				/* setup the stack */
	ldr	r0, _TEXT_BASE		/* upper 128 KB: relocated uboot */
	sub	r0, r0, #MALLOC_LEN	/* malloc area */
	sub	r0, r0, #GBL_DATA_SIZE	/* gd_t */
#ifdef CONFIG_USE_IRQ
	sub	r0, r0, #(BOOT_STACKSIZE_IRQ + BOOT_STACKSIZE_FIQ)
#endif
	sub	sp, r0, #12		/* leave 3 words for abort-stack */

clear_bss:
	ldr	r0, _bss_start		/* find start of bss segment */
	ldr	r1, _bss_end		/* stop here */
	mov	r2, #0x00000000		/* clear */

clbss_l:
	str	r2, [r0]		/* clear loop */
	add	r0, r0, #4
	cmp	r0, r1
	ble	clbss_l

	ldr	pc, _start_armboot

_start_armboot:
	.word	start_armboot

首先说明这几个值的含义：
_start: 	代码段的起始位置，入口位置。
_TEXT_BASE:	在Makefile中指定的代码段起始位置。
_bss_start:	在ucboot.bin的最末尾的一个段
_bss_end:	就是ucboot.bin的_end
_armboot_start:	代码段的起始位置

首先，系统复位以后是从地址0x00000000开始执行的，上电复位后的FLASH中_start例程位
于这个位置，也就是复位以后执行的第一条代码的位置。
relocate的第一段过程，比较_start和_TEXT_BASE，如果相等，表示直接在FLASH上执行，
不需要拷贝到内存，这时直接跳转到设置栈的代码，不需要执行重定位操作。
relocate的第二段过程，设置r2的值为(_start + _bss_start - _armboot_start)，这个
值代表整个u-boot文件镜像的大小（BSS段在镜像中不占空间）。
relocate的第三段过程，通过一组寄存器(r3~r10)，把r0所指向的位置的内容拷贝到r1所
指向的位置。拷贝的内容的大小为(r2-r0)即(_bss_start-_armboot_start)。
下面开始设置栈的过程，首先定位代码段基地址，然后向下减去动态分配区堆的大小，然
后再减去全局数据变量的大小，这两个大小都是预先配置的值。如果配置了中断的话再减
去中断栈的大小，然后再空出12个字节的位置作栈保护。这里可以看出uboot的栈是向下增
长的。
然后是初始化BSS过程，从_bss_start到_bss_end这片数据区初始化为0，这片区域位于
ucboot镜像的顶部。

函数start_armboot分析
首先初始化全局数据变量gd，使其指向一个gd_t结构，这个结构位于堆以下，栈以上。这
个空间是在relocate之后，设置栈的时候预留出来的，大小为CONFIG_GBL_DATA_SIZE。
然后初始化gd->bd指向一个bdinfo数据结构，并初始化之。计算到ucboot镜像的大小为
(_bss_start-_armboot_start)。
依次调用init_sequence[]数组内的初始化函数，包括cpu，板子，环境变量，中断，串口，
终端，DRAM等。
然后初始化闪存并打印闪存大小信息。
初始化堆（内存动态分配区，位于ucboot代码段以下MALLOC_LEN的位置）
重定位环境变量，如果环境变量是嵌入在代码段的那么让指针指向代码段对应的偏移位置
即可。否则的话，需要在堆空间给环境变量分配空间。如果env设置为无效或者缺省env大
小大于配置的ENV大小则会出错。如果正常则将缺省环境变量拷贝到目的位置。设置有效
位并设置gd->env_addr为env-ptr->data
然后配置IP地址，MAC地址
初始化设备（主要是串口），初始化跳转表，初始化终端（根据是否在环境变量中设置了
终端有两种实现）
然后打开中断
初始化以太网
初始化vtss相关参数
通过do_initcalls()调用（通过module_init()）注册的initcall类型初始化函数
然后进入主循环

__init和__initcall
__init会把代码放到init.text段，这些代码的内存在调用后会被释放。这个是gcc的扩展。
__initcall用来收集某些init函数，以便按照顺序调用这些函数。这个是链接器脚本确定
的，这个是Linux的设计。


******************************************************************************
关于console

数据结构
static int ctrlc_disabled = 0;
static int ctrlc_was_pressed = 0;
chardev_t stdio_devices[] = {NULL, NULL, NULL};
char* stdio_names[] = {"stdin", "stdout", "stderr"};

操作方法
以下函数用来设置终端
int console_assign(int file, char *devname);
    通过设备名字为某个文件描述符设置关联的设备，成功返回0，出错返回-1，调用
    console_setfile()，是供外部的接口函数。
int console_init_f(void);
    在init_sequence中调用的初始化函数，设计全局数据中关于终端的标志，返回0。
int console_init_r(void);
    在设备初始化后调用的终端后期初始化函数，会设置标准输入输出与设备的关联关系。
    返回0。这个函数根据CFG_CONSOLE_IS_IN_ENV分成两种。
static int console_setfile(int file, chardev_t *dev);
    通过设备数据结构为某个文件描述符设置关联的设备，成功返回0，出错返回-1。
    内部使用，设置stdio_devices[]数组。

以下五个函数操作串口设备，通过stdio_devices
int fgetc(int file);
void fprintf(int file, const char *fmt, ...);
void fputc(int file, const char c);
void fputs(int file, const char *s);
int ftstc(int file);
以下通过调用f族的函数实现
int getc(void);
int tstc(void);
void putc(const char c);
void puts(const char *s);
void printf(const char *fmt, ...); 	最后调用puts
void vprintf(const char *fmt, va_list args); 最后调用puts
void serial_printf(const char *fmt, ...); 直接调用串口驱动的方法。


******************************************************************************
关于device

数据结构
LIST_HEAD(char_devices);
LIST_HEAD(block_devices);

操作方法
chardev_t *device_new(void);
    分配一个字符设备数据结构并将所有域初始化为0。
void device_free(chardev_t *dev);
    空
int device_register(chardev_t *dev);
    将dev链到字符设备链表中
struct list_head *devices_get_list(void);
    返回&char_devices
int devices_init(void);
static void drv_system_init(void);
    生成一个字符设备，设置该字符设备结构的各个字段。
chardev_t *search_device(int flags, char *name);
    返回指定flag和指定名字的设备
chardev_t *search_device_flags(int flags);
    返回满足指定flag的第一个设备


******************************************************************************
关于env
CONFIG_ENV_OVERWRITE		串口和MAC地址是否可以更改
CONFIG_OVERWRITE_ETHADDR_ONCE	MAC地址只可以更改一次，即未设置时初始设置一次。
CONFIG_ENV_FLASH		环境变量保存在FLASH中
CONFIG_ENV_NVRAM		环境变量保存在NVRAM中
CONFIG_ENV_NAND 		环境变量保存在NAND中，需要支持NAND
CONFIG_ENV_NOWHERE		环境变量不保存

CFG_ENV_ADDR			ENV的位置
CFG_ENV_SIZE			ENV的大小（这里定义为FLASH的SECT大小）
CFG_ENV_OFFSET			ENV在FLASH上的偏移
CFG_ENV_SECT_SIZE		同上
CFG_ENV_ADDR_REDUND 		冗余备份位置
CFG_ENV_SIZE_REDUND		冗余备份大小
CFG_ENV_OFFSET_REDUND		冗余备份偏移
CFG_REDUNDAND_ENVIRONMENT
CFG_LOAD_ADDR
ENV_SIZE			环境变量大小，不包括CRC校验和标志
ENV_IS_EMBEDDED			环境变量编译到二进制中
ENV_HEADER_SIZE			CRC校验和标志（当前还是备份）的大小

CONFIG_BOOTARGS
CONFIG_BOOTCOMMAND
CONFIG_RAMBOOTCOMMAND
CONFIG_NFSBOOTCOMMAND
CONFIG_BOOTDELAY
CONFIG_LOADS_ECHO
CONFIG_ETHADDR
CONFIG_ETH1ADDR
CONFIG_ETH2ADDR
CONFIG_ETH3ADDR
CONFIG_ETHPRIME
CONFIG_IPADDR
CONFIG_SERVERIP
CONFIG_ROOTPATH
CONFIG_GATEWAYIP
CONFIG_NETMASK
CONFIG_HOSTNAME
CONFIG_BOOTFILE
CONFIG_LOADADDR
CONFIG_PREBOOT
CONFIG_EXTRA_ENV_SETTINGS
CONFIG_AUTOLOAD
CFG_ENV_SECT_SIZE
CFG_CONSOLE_IS_IN_ENV
CFG_CONSOLE_ENV_OVERWRITE

简单介绍
形如"name=value"的C风格字符串，保存在一个表中，该表以"\0"结尾。新项总是加在表
尾端，删除时剩下的表项会往前移动。修改值的话相当于删除旧表项再添加新表项。
environment数据结构中有一个32位的CRC校验码覆盖数据部分。

数据结构
uchar default_environment[];	在没有设置环境变量时使用缺省环境变量表
extern uchar environment[];	自定义的环境变量表
env_t environment __PPCENV = {ENV_CRC, 1, {""}};

char *env_name_spec;
#define __PPCENV__	__attribute__ ((section(".text")))
#define __PPCTEXT__	__attribute__ ((section(".text")))
typedef struct environment_s {
	unsigned long crc;		/* crc32 over data bytes */
	unsigned char flags;		/* active / obsolete */
	unsigned char data[ENV_SIZE];	/* data bytes */
} env_t;

char *env_name_spec = "Flash";
static env_t *flash_addr = (env_t *)CFG_ENV_ADDR;
env *env_ptr = (env_t *)CFG_ENV_ADDR;
gd->env_addr;

static env+t *flash_addr_new = (env_t *)CFG_ENV_ADDR_REDUND;
static ulong end_addr = CFG_ENV_ADDR + CFG_ENV_SECT_SIZE - 1;
static ulong end_addr_new = CFG_ENV_ADDR_REDUND + CFG_ENV_SECT_SIZE - 1;
#define ACTIVE_FLAG 	1
#define OBSOLETE_FLAGS 	0

操作方法
int env_init(void);	主要通过计算CRC校验和设置env地址值和有效标志。
void env_crc_update(void);  更新env-ptr指向的crc。
uchar *env_get_addr(int index); 返回env中index位置的指针
int env_complete(char *var, int maxv, char *cmdv[], int bufsz, char *buf);
用于名令自动完成

void env_relocate(void);	将env重定位到ram中，如果不是使用缺省，调用spec
void env_relocate_spec(void);	将env从flash拷贝到内存中的位置。

uchar (*env_get_char)(int);
uchar env_get_char_spec(int);
static uchar env_get_char_init(int index);
uchar env_get_char_memory(int index);

static int envmatch(uchar *s1, int i2);
char *getenv(char *); 在环境变量表中查找对应名字的环境变量并返回该环境变量指针
int getenv_r(char *name, char *buf, unsigned len);
int saveenv(void);
void setenv(char *, char *);

int _do_setenv(int flag, int argc, char *argv[]);
int do_askenv(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
int do_printenv(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
int do_saveenv(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
int do_setenv(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);



******************************************************************************
关于启动操作系统


******************************************************************************
关于命令以及自动完成
