Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

内核中的链表原理、使用和实现
内核在include/linux/list.h中实现了一个循环双链表，基本上内核中所有的链表都采用
它。关于并发访问需要使用者自己来进行控制。下面先阐述用法，再谈实现。

*** 用法
0.  链表结构：struct list_head {struct list_head *next, *prev;};
1.  包含头文件<linux/list.h>
2.  定义一个链表头：
        a. 直接定义法： struct list_head todo_list;	/* 需要初始化 */
	b. 使用内核宏： LIST_HEAD(todo_list);		/* 调用后者实现 */
			LIST_HEAD_INIT(todo_list);	/* 已进行了初始化 */
3.  初始化链表头，只有直接定义方式才需要初始化
	调用内核函数INIT_LIST_HEAD(&todo_list);
4.  在你要用链表管理的数据结构中增加类型为struct list_head成员。
5.  链表操作方法API：
    a. list_add(struct list_head *new, struct list_head *head);	/* 头部插入 */
    b. list_add_tail(struct list_head *new, struct list_head *head); /* 尾部 */
    c. list_del(struct list_head *entry);	/* 删除指定项 */
    d. list_del_init(struct list_head *entry);	/* 删除并重新初始化这个链表指针  */
    e. list_move(list_head *entry, struct list_head *head);	/* 移到头部 */
    f. list_move_tail(list_head *entry, struct list_head *head);/* 移到尾部 */
    g. list_empty(list_head *head);		/* 检测空，非空返回非零 */
    h. list_splice(struct list_head *list, struct list_head *head);
    						/* 链接两个链表 */
    i. list_entry(struct list_head *ptr, type_of_struct field_name);
    j. list_for_each(struct list_head *cursor, struct list_head *list);
    k. list_for_each_prev(struct list_head *cursor, struct list_head *list);
    l. list_for_each_safe(struct list_head *cursor, struct list_head *next,
			  struct list_head *list);
    m. list_for_each_entry(type *cursor, struct list_head *list, member);
    n. list_for_each_entry_safe(type *cursor, struct list_head *list, member);

---------------------------------------
References:
Linux Device Driver Chapter 11
