Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

JFFS2 - Journalling Flash File System version 2
See also: JFFS, LogFS, UBIFS, YAFFS

node：节点，文件系统的逻辑概念
block: 块，是文件系统的逻辑概念。
sector：扇区，也叫擦除块，是个物理概念

*******************
*      特性
*******************
支持NAND闪存，支持硬链接，支持三种压缩算法，性能更高的垃圾回收算法，支持日志。
inode和dirent节点
JFFS2处理block，即闪存的最小擦除单元。
垃圾回收器在后台运行，将脏块（至少包含一个失效节点）转为空闲块（不包含节点）。
缺点：
必须在挂载时扫描所有的节点，这个操作很慢。写很多小块数据时会导致负的压缩比。所
以没有办法确定剩下多少空闲块，这是由于这个依赖于额外数据被压缩的情况和写的顺序。

JFFS2不像之前的闪存文件系统一样在闪存设备上使用一个翻译层来模拟硬盘，而是直接
在闪存芯片上放置文件系统。JFFS2由Red Hat开发，基于Axis Communications AB的JFFS。

与原始JFFS不同，JFFS2单独对待闪存的每个擦除块。它决不会跨块来写节点，也不会处理
有这类节点的文件系统，任何跨擦除块的节点会被JFFS2忽略，因而其包含的数据会丢失。
如果当前块上没有足够的空间写一整个节点的话，JFFS2会把这个空间留空在下一个新的块
上写。JFFS2始终从一个擦除块的开始处写，并且不期望中间有空洞，一个擦除块的任何空
闲空间应该从空闲开始到擦除块尾端都是空闲的。如果JFFS2在一个擦除块的节点s之间发
现了空闲空间，尽管这除了有点浪费外并没有什么坏处，它还是会打印一句话：
jffs2_scan_empty(): Empty block at 0x0012fffc ends at 0x00130000
		    (with 0xe0021985)! Marking dirty
这种情况可能是你用mkfs.jffs2创建JFFS2镜像时提供了错误的擦除块大小（用-e选项）造
成。缺省是64KB，这是你常碰到的擦除块大小，如果以较小的擦除块来创建JFFS2镜像除了
会产生一些抱怨信息外并没什么坏处，当发现了如上信息，那么检查一下你的擦除块大小
参数是否合适。

擦除块概要（Erase Block Summary）
EBS的目的是加速挂在过程。它在每个擦除块尾部保存了概要信息。在挂载的时候不再需要
单独扫描所有的节点以及读取擦除块的所有页面，而只要读取这个小的概要信息就足够了。
这个概要信息保存在一个JFFS2_FEATURE_RWCOMPAT_DELETE节点中，在挂载的时候如果在擦
除块尾部没有概要节点，则会执行原定的扫描过程。
启用EBS时，这个节点在写数据过程中自动生成，但是在用mkfs.jffs2创建了JFFS2镜像之
后你必须用一个叫做sumtool的用户层工具向其中插入概要信息，比如：
    $mkfs.jffs2 -rdir -oout.jffs2 -e128KiB
    $sumtool -iout.jffs2 -oout-sum.jffs2 -e128KiB
EBS可以工作于NOR和NAND闪存，通常来说在NAND闪存和擦除块大的闪存上加速比率要高一
些。

*******************
*   JFFS2 FAQ 
*******************
为什么无法挂载JFFS2并且看到"Magic bitmask 0x1985 not found"错误信息？
如果无法挂载JFFS2文件系统并且看到许多如下消息：
jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000024: 0x2b10
			 instead 
	...
Further such events for this erase block will not be printed
这表示在你闪存设备上的数据不是有效的JFFS2文件系统格式。对此没有唯一解决方案，
但是我们可以尝试提供一些点子来修正此问题。
首先需要回答的第一个问题是，为什么我闪存设备上的数据不正确使得JFFS2拒绝处理它。
可能原因有许多，比如：
(1) 你的闪存设备有严重的bug导致读出的是垃圾而不是有效数据
(2) 你烧写了垃圾数据而不是有效的JFFS2镜像
(3) 你没有正确烧写JFFS2镜像导致你闪存以垃圾结尾，尽管原镜像正确
(4) 你忘了在烧写前先擦除它，等等
不管怎么，JFFS2不会在它能找到正确数据时抱怨，如果它抱怨了，那么它读了错误数据。
一个常见错误是使用/dev/mtdX或者/dev/mtdblockX设备访问NAND闪存上的JFFS2镜像，
比如：
	$cp jffs2_fs.img /dev/mtd2
这是不正确的，因为当处理NAND闪存时必须跳过坏块并且只在NAND页大小的聚集上写。请
使用nandwrite组件替代。
此外，别忘了在烧写镜像前擦除你的闪存。你可以使用flash_eraseall组件来做。它会确
保读回擦除的MTD设备并且检查是否仅仅写了0xFF。
你可以通过在烧写完镜像后将镜像读出来比对的方法来判断是否烧写成功。在nand闪存上
推荐使用nandread组件。
你可以做一下试验来保证JFFS2工作正常，擦除你的MTD设备并且挂载到JFFS2。你会以一个
空间系统结束。拷贝一些文件到这个JFFS2文件系统并且卸载它。然后再挂载，查看是否
成功无错挂载。如果是，那么说明这不太可能是JFFS2的BUG。

可以在硬盘上使用JFFS2吗？
首先，JFFS2是为MTD设备设计的，不是为像硬盘一样的块设备设计的。它们是两类非常不
同类型的设备。请参考mtd页面相关解释二者不同的小节。
现在你明白了你要在并不是为之设计的设备上使用JFFS2，行吗？很明显，通常是不行的。
在block2mtd驱动下使用JFFS2是可能的。这个驱动在块设备上模拟了MTD设备以便你为
JFFS2提供模拟的MTD设备来利用上面的文件系统。但是在性能很糟时请不要抱怨。
由于闪存设备的特性，JFFS2与传统的面向HDD的文件系统大不相同。并且它的一大缺点是
随着闪存容量的增大，挂载的时间也线性的随之增大。所以当心你的块设备很大时在挂载
的时候吃光内存，并且挂载用时超长。此外，JFFS2仅实现了write-through缓存功能（而
传统的文件系统拥有写回(write-back)缓存功能），并且实现了许多在使用硬盘时根本不
需要的操作。
所以在用这个前三思。另外，没人保证block2mtd驱动没有缺陷。它一般用来做调试用途，
在主机环境下可以方便的利用模拟出来的mtd设备而不用在目标板上调试。当然，如果你
测试了它并且没有问题，那就放心用吧。

可以在优盘/CF卡等上面使用JFFS2吗？
优盘，CF卡以及其它的闪存媒介并不是MTD设备。它们是块设备。它们里面确实包含了闪存
芯片，但是它们也包含了某些用来模拟块设备的翻译层。这个翻译层实现在硬件中。所以
从设备外面来看它们就确实是块设备，而不像MTD设备。
请阅读上一小节：在块设备上使用JFFS2。
可以知道，回答是很有可能这样，技术上可以，但请看清楚你在做什么。通常这是一个坏
想法。使用ext2这类传统文件系统会更好。
另外注意，这类设备是“黑盒”。通常实现它们的闪存到块设备翻译层是不公开的。而且很多
时候这些算法很愚蠢。比如，许多优盘和存储卡会在重启或者断电时丢失数据，所以，请
多加小心。

JFFS2输出了一些信息，是有什么问题吗？
JFFS2采用了让用户可以完全知晓当前正在发生什么的设计理念。这样可以提醒那些粗心的
新手。当你知道为什么输出下面的信息时可以将其移到一个高等级的日志级别。
  Empty flash at 0xxxxxxxxx ends at 0xxxxxxxxx
下面这个信息在一块数据只被写了一部分时产生。通常这不是一个问题的标志。
  Name CRC failed on node at 0x00b620c8: Read 0x640c8ca3, calculated 0x795111fe
或者类似的关于CRC失败的消息。如果你曾经有不干净的重启操作（有害的），这仅仅意味
着在以下情况下发生了重启（1）在写入数据或者sync期间（2）GC在工作时（3）数据已经
更改但尚未sync。在第一和第三种情况下，你仅仅是丢失了你最后写入的数据，在第二种
情况下，你不会丢失什么。错误的节点会被垃圾收集器回收并且信息被删除。
但这也可能意味着你闪存上的数据由于校验错误而损坏了，不幸的是JFFS2不能区分非正常
重启和实际闪存损坏之间的区别。但后者通常较少出现。
你不可以在新内核上使用旧版的JFFS2文件系统。
请及时更新你的mtd组件并且使用新的mkfs.jffs2

为什么无法loop挂载一个JFFS2镜像？
JFFS2镜像不可以被loop挂载。LOOP设备本质上是表示成块设备的文件的驱动。但是JFFS2
工作在MTD设备上，是不同的。所以需要一个mtdloop设备，但是还没有人实现它。
唯一的操作JFFS2镜像的方法是将其拷贝到一个mtdram设备并且使用JFFS2挂载该设备。
此外，如果你比较失望，那么修正jffs2_dump来从镜像重建文件系统，并不难，所有基本
的工作都已经有了。

挂载JFFS2文件系统需要mtdblock么？
通常，不需要mtdblock来挂载JFFS2文件系统。你可以用MTD设备名或者次设备号来指定一
个包含JFFS2文件系统的MTD设备。比如，这两个：
  #mount -t jffs2 mtd2 /foo
  #mount -t jffs2 mtd:name_of_device /foo
这里假定该设备确实包含了一个有效的JFFS2文件系统
有两种情况这个会失败。第一种是当JFFS2用作根文件系统时。当前这需要mtdblock设备驱
动来在内核命令行上指定root=。第二种情况是mount程序不能很好的处理上述格式，典型
的busybox的mount就不可用。

怎样让2.6内核识别JFFS2为根文件系统？
在2.6内核下，你需要在内核命令行上如下指明以使用JFFS2作为根文件系统：
  rootfstype=jffs2

如何保证数据被写入到闪存里面？
对于NOR闪存，每次写都直接写到闪存里。
对于NAND闪存和NOR ECC闪存，我们用一个写缓存来每次写入整页到闪存芯片。这意味着在
断电前不进行冲刷的话会丢失数据。这里有些机制可以保证写缓冲区被冲刷。你可以在你
的应用程序中使用fsync()或者sync()来强制冲刷写缓冲区。JFFS2有一个定时冲刷机制，
5s内再没有新的向文件系统的写入时，就会冲刷。该时间依赖于kupdated的周期时间，而
该周期时间可以通过/proc/sys/vm/dirty_expire_centisecs来调整。
当你卸载文件系统时也会冲刷缓冲区。
如果分区被用作根文件系统（不可以被卸载），则该文件系统应该在关机是重新以只读方
式挂载。JFFS2此时会由垃圾回收器冲刷缓冲区，这个操作执行错误会导致文件系统产生
CRC错误的警告。这会收集那些稍后将被回收机制回收的垃圾块。这种行为可以在系统崩
溃时察觉到。

如何把镜像烧录到闪存中？
现在有如下几种方式可以做到：
    通过Linux烧录
    通过启动加载器（bootloader）烧录
    通过JTAG烧录
    在出厂时烧录
对于NOR闪存没有什么限制。对于NAND闪存，参见NAND FAQ小节。

JFFS2怎么处理NAND闪存中将要坏掉的块？
如果在写入一页时发生错误，JFFS2会尝试修复数据。如果那个块包含了已经写入到闪存的
节点，该块被重新归类到已坏但仍在使用的列表（bad_used_list）中。然后尝试恢复写缓
冲区，这里会考虑部分写入到闪存中的数据。一旦写缓冲区恢复，继续正常的操作。垃圾
回收器负责将有效的节点从重新归类的块中移走。
一旦垃圾回收器将所有有效节点写入到另一个擦除块，坏块就被移到等待擦除链表。这里
JFFS2会擦除该擦除块。如果擦除失败，它会被重新放入等待擦除链表重试一次。如果在设
备级失败三次，那么就会在OOB区标记它为坏块，并且归类到坏块链表（bad_block_list）
。如果擦除成功，在OOB中将该块标记为空闲，并且被归类到空闲链表。需要这样做是因为
NAND闪存会由于重写或者写入打断等错误而随机失败。一个块擦除操作会清除这些问题。

cleanmarker是什么，用来做什么？
clearnmarker是一个特殊的JFFS2节点，在擦除块被擦除后写入到块开头。在NOR闪存上，
它就是一个位于块开始处的特殊的小JFFS2节点。在NAND闪存上，它位于空闲区的第一页。
使用cleanmarker的主要原因是用来保证块擦除操作正确完成。块上所有的字节为0xFF并不
肯定意味着该块可用。比如，如果在块擦除的最后时刻不正常重启，该块可能含有不稳定
的位，有时读出时是'1'，有时则是'0'。
当为JFFS2准备一个闪存分区时，推荐在擦除块上使用clenamarker。这可以通过使用MTD组
件中的flash_eraseall时应用-j选项实现。否则，JFFS2会擦除所有的块为0xFF并且没有
cleanmarker。这完全是不必要的浪费时间。

如何编译mkfs.jffs2？
mkfs.jffs2组件需要ACL和zlib库。Fedora下安装libacl-devel和zlib-devel包。Debian下
安装libacl1-dev和zlib1g-dev包。

---------------------------------------
参考文件:
http://www.linux-mtd.infradead.org/doc/jffs2.html
http://www.linux-mtd.infradead.org/faq/jffs2.html
http://www.linux-mtd.infradead.org/faq/nand.html
http://www.linux-mtd.infradead.org/faq/general.html
