Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

*******************
*    MTD概览
*******************
MTD（Memory Technology Devices）子系统在原始闪存设备上提供了一个抽象层。使得对
于不同类型和技术的闪存可以使用相同的API操作。比如NAND，OneNAND，NOR，AG-AND，
ECC'd NOR等等。

MTD子系统不处理像MMC，eMMC，SD，CompactFlash等这类块设备。这类设备并不是原始的
闪存设备，它们内部拥有一个闪存翻译层使得它们看起来像是块设备。这类设备归类于
Linux块设备子系统，不属于MTD。有个FAQ来概述了在块设备和MTD设备之间的主要区别，
在UBIFS文档的“原始闪存和FTL设备”节则更详细讨论了它们的不同。

MTD子系统有如下接口：
MTD字符设备，通常通过/dev/mtd0, /dev/mtd1等来使用，这类字符设备提供了访问原始闪
存的IO接口。它们提供了大量的ioctl调用用来擦除擦除块，标记擦除块坏或者检测擦除块
是否坏掉，获取MTD设备的信息等。
sysfs接口提供了系统内MTD设备的全部信息。这个接口可以方便的扩展并且鼓励开发者尽
可能使用sysfs接口替代旧式ioctl或者/proc/mtd接口。
/proc/mtd接口提供了通用的MTD信息。这是一个遗留接口，sysfs提供了更多信息。

MTD子系统支持带硬件或软件ECC的裸NAND闪存，OneNAND闪存，CFI NOR闪存及其它闪存类型
此外，MTD支持遗留的FTL/NFTL翻译层，M-Systems' DiskOnChip 2000 和Millennium芯片，
以及PCMCIA闪存。但是对应的驱动都很老维护更新不及时。

*******************
*    MTD测试
*******************
MTD子系统包含了一系列的测试，你可以用它来检验你的闪存硬件和驱动。这些测试用例
位于drivers/mtd/tests目录。可以通过启用CONFIG_MTD_TESTS来把它编译进内核。
测试用例包括：
    mtd_speedtest
    mtd_stresstest
    mtd_readtest
    mtd_pagetest
    mtd_oobtest
    mtd_subpagetest
    mtd_torturetest

*******************
*   mtdblock
*******************
MTD中的mtdblock驱动是一个用来在MTD设备上模拟块设备的古老工具。它甚至没有坏擦除
块处理机制，所以实际上不可以用来处理NAND闪存。并且它通过缓存一整个闪存擦除块到
RAM中来工作，提交修改请求时，首先擦除整个擦除块，然后再将修改后的内容写回。这
意味着mtdblock没有尝试做任何优化，并且在掉电时会丢失大块的数据。最后，但远不止
此，mtdblock没有实现任何平均读写演算算法。

人们经常将mtdblock认作通用FTL层并且试图在使用了mtdblock的裸闪存上使用基于块的
文件系统。大多数情况下这是错误的。换句话说，除非你确切清楚你在做什么，否则不要
使用mtdblock。

此外还有一个只读版本的这种驱动，它没有缓存和擦除/写回能力，主要用于uclinux中当
要求的RAM过大时使用。

*******************
*      FAQ
*******************
MTD设备是块设备还是字符设备？
首先，MTD表示存储技术设备，所以它就是指MTD。
传统上，UNIX只认识块设备和字符设备。字符设备是类似键盘或者鼠标的这类设备，你必
须从它读取当前数据，但是不可以定位也没有大小。块设备有固定的大小并且可以定位，
它们恰好组织成许多字节的块，通常为512字节。
闪存既不满足块设备描述也不满足字符设备的描述。它们表现的类似块设备，但又有所不
同。比如，块设备不区分写和擦除操作。因此，一种符合闪存特性的特殊设备类型诞生了，
就是MTD。
所以MTD既不是块设备，也不是字符设备。假如需要，有方法对它进行转化。但是这些转化
都和原有的不同。

闪存设备和块设备有什么不同？
以下表格描述了块设备和原始闪存设备之间的不同。注意：SSD, MMC, eMMC, RS-MMC, SD,
mini-SD, micro-SD, USB闪存, CompactFlash, MemoryStick, MemoryStick Micro以及其
它FTL设备是块设备，并不是原始闪存设备。当然，硬盘也是块设备。
    +----------------------------------+-----------------------------------+   
    |             块设备               |               MTD设备             |
    +----------------------------------+-----------------------------------+   
    |           由扇区组成             |             由擦除块组成          |
    +----------------------------------+-----------------------------------+   
    |     扇区小（512或者1024字节）    |       擦除块大（典型的128K字节）  |
    +----------------------------------+-----------------------------------+   
    | 提供2个主要操作（读扇区和写扇区）|    提供3个主要操作：读，写，擦除  |
    +----------------------------------+-----------------------------------+   
    | 坏块被硬件（或FTL）重映射并隐藏  |  坏块不会被隐藏，应该在软件中处理 |
    +----------------------------------+-----------------------------------+   
    |   扇区缺乏已坏属性（FTL会提供）  | 可擦除块会在10^3到10^5擦写之后会坏|
    +----------------------------------+-----------------------------------+   

我可以通过MTD设备挂载ext2文件系统吗？
ext2, ext3, xfs, jfs, fat以及其它传统文件系统都是与块设备匹配的，它们按照块设
备设计。闪存不是块设备，它们是完全不同的怪兽。
请不要被USB棒，MMC，SD，CompactFlash以及其它流行的便携设备迷惑，尽管它们叫做闪
存，但它们不是MTD设备。它们脱离了MTD子系统的范畴。
为了在一个MTD设备上使用某种传统文件系统，你需要一个在MTD设备上模拟块设备的软件
层。这种层往往叫做闪存翻译层（FTL）。
在Linux的MTD子系统里有一个极简单的FTL层：mtdblock。它在MTD设备上模拟块设备。还
有一个模拟只读块设备的mtdblock_ro模块。当你装载了这个模块以后，它会为系统内的
每个MTD设备创建一个块设备。然后可以通过/dev/mtdblockX设备节点访问该块设备。
但在很多时候使用mtdblock是一个坏主意，因为如果你改变了你mtdblockX设备的任何扇区
时，它会读取整个对应的擦除块到内存，然后擦除整个擦除块，改变内存中的扇区，然后
写回。问题很明显，在擦除块被擦除后突然断电了，你会丢失上面的所有块设备扇区。很
可能这个闪存就此坏掉，因为大多数情况下你所修改的块会是分区表所在的擦除块，位于
FAT/bitmap/inode 表/etc。
不幸的是，创建一个好的FTL层很难，尚且没有人为Linux实现一个。但是现在当我们拥有
UBI时，在UBI实现这个就很简单了。
很明显mtdblock_ro是为了挂载只读文件系统或只读挂载区。比如，可能有人用SquashFS作
为它存放压缩数据的方式。所以以读写方式使用mtdblock之前再三思考一下，并且不要在
NAND上使用它，因为它不支持坏块处理。

point()和unpoint()函数用来干什么？

不管我写还是擦除我的MTD设备，我总是出错？
某些NOR芯片以所有擦除块处于锁定状态的方式上电。MTD层默认并不解锁这些设备。如果
你从用户态访问这些设备，你可以使用flash_unlock工具来解锁MTD设备。如果你使用MTD
设备作为你的可读写文件系统，你还需要让bootloader在启动内核前解锁这些擦除块，或
者为你的板子在MTD映射驱动中增加解锁代码。已知会锁定的芯片有：Intel 28FxxxP30
Intel GE28F256L30T。

怎么编译mtd-utils代码树？
你需要安装工具所依赖的库。请参照mkfs.jffs2和mkfs.ubifs的依赖信息。
mkfs.jffs2组件依赖ACL，zlib库。debian下请安装libacl1-dev和zlib1g-dev包。
mkfs.ubifs组件依赖zlib，lzo和uuid库。前两个用来压缩数据，最后一个用来为文件系
统生成统一通用ID号。在Debian下要安装zlib1g-dev，libzo2-dev和uuid-dev包。

### 闪存分区布局是怎么指定的？
硬盘分区表位于硬盘的一个保留扇区。
如果闪存设备模拟硬盘，则分区表仍然需要，比如CF卡之类的设备。
在大多数嵌入式系统中，闪存设备大多不模拟硬盘。MTD映射驱动提供了访问闪存的方法。
闪存映射驱动既可以硬编码一个分区布局，从bootloader传递的内核启动命令行读这个分
区布局，也可以从闪存中读取分区布局。
即便没有分区支持，MTD层提供了将整个闪存作为一个MTD设备访问的方法。如果添加了MTD
分区支持，则每个MTD分区会被导出为一个独立的MTD设备。每个设备有一个描述性名字，
可以通过如下命令查看：
    #cat /proc/mtd

### 闪存适合用哪种文件系统？
对于传统的NOR闪存，MTD块设备提供了一个粗糙的块设备模拟。传统的硬盘使用512B的扇
区。MTD块设备模拟扇区拓扑，但是有严重的写性能问题。因为许多闪存的擦除块大于64KB
更新一个512B的扇区会要求改写整个闪存擦除块。这种写方法慢而且导致了多次写会影响
寿命。
由于写性能问题，MTD块设备适合只读文件系统。一些适用于嵌入式的典型只读文件系统有
CRAMFS和ROMFS。
CRAMFS拥有压缩每4KB簇的优点，提供了2:1的压缩比。
要求读写的可以考虑采用面向闪存的文件系统比如JFFS2。
JFFS2是一个日志闪存文件系统，JFFS2使用自己关联的缓冲区绕过了块设备层并且可以直
接向其下面的闪存写入。当然，JFFS2支持只读和读写模式操作。
对于NAND闪存，文件系统必须支持面向NAND，因为读写都必须实现ECC错误检测和纠正。
JFFS2和YAFFS文件系统是NAND兼容的。

### 使用MTDCHAR设备的目的是什么？
MTD设备有两类方式：一种是MTD块设备驱动，一种是MTD字符设备驱动。块设备为了使用
文件系统提供了512扇区的外部接口，字符设备提供了对一个MTD设备或MTD分区的线性视
角。你可以向访问文件一样访问这个设备，可以适用标准的UNIX组件来读这个闪存。假定
MTD设备0是整块闪存，则以下命令会将整个闪存的镜像导出到一个文件：
    #cat /dev/mtdchar0 > /tmp/flash.bin
写闪存需要擦除以后再写不能直接写
MTD字符设备会向闪存写数据，但是它不会执行擦除命令。在NOR闪存上，写命令只能把位1
变为位0。把位0变为位1需要的是擦除命令。MTD字符设备提供了IOCTL来实现擦除操作。
闪存的拓扑信息可以通过MEMGETINFO命令来获取，它会返回擦除块的大小，通常是64KB或
者128KB，如果有小的启动块则忽略。闪存的精确拓扑信息可以使用MEMGETREGIONCOUNT命
令来获得。一旦闪存块拓扑确定，则MEMERASE命令既可以执行来擦除指定块了。
MTD提供了用户层程序来执行自动擦除。一下命令会正确的将新的映像写入到闪存中。假定
闪存不支持加锁，或者块已经解锁。否则需要调用flash_unlock先解锁。
    #flash_eraseall /dev/mtdchar0
    #cat /dev/mtdchar0 < new.bin

### 如何通过用户空间程序访问MTD
如果闪存已经作为一个文件系统挂载，则通常的open/close/read/write系统调用都可以
工作。否则闪存可以通过MTD字符设备来访问。

### 如何更新bootloader，内核和根文件系统映像
通常每个部分都由其独立的MTD分区，可以通过MTDCHAR设备访问。通常内核在RAM中执行，
尽管有些手持设备确实在闪存中执行。当内核在RAM中执行时，可以随意更改内核闪存分
区。根文件系统是特殊情况，如果更新过程中在根文件系统上有文件打开了，会出问题。
即使没有打开的文件，也会导致JFFS2根文件系统的内部数据结构与闪存内容不一致。
更新根文件系统通常是一个文件替换的过程，有时打包一下会比较方便。

### 在升级过程中的冗余备份和错误纠正？
大多数冗余备份机制要求boot-loader支持，至少，你应该在将映像写入flash前在DRAM
中进行检查以后再写入。冗余备份的量取决于你的稳定性需求和成本。

### 怎么做空的JFFS2分区？
根据JFFS2 FAQ，JFFS2用cleanmarkers标记空擦除块，在擦除的时候用'-j'选项就可以在
擦除块开始处添加clenamarkers信息。

### JFFS2为了自身的记账需求有多少空间开销？
JFFS2需要5个空闲擦除块来实现垃圾收集，在一个每单元两位的设备上比如Intel的
StrataFlash或者Spansion的MirrorBit，擦除块大小是128KB，所以浪费的空间是0.5MB。
空闲擦除块的需求定义在fs/jffs2/nodelist.h，JFFS2_RESERVED_BLOCK_BASE参数默认
为3。如果改变这个参数为1，则可以节省2个擦除块。如果改变这个值，你需要在作一些
压力测试来检测是否有错，缺省的3是为了最大的可靠性。

### 在挂载JFFS2文件系统时需要提供什么参数么？
以读写方式挂载的JFFS2文件系统一个有用的选项是'noatime'，表示关闭访问时间更新，
这样不会在每次访问文件后更新访问时间，当作为根文件系统挂载时，有两种方式增加该
选项，一种是在内核启动命令行上指定'rootflags=noatime'，一种是在挂载时添加
'-o remount, noatime'选项，表示重新挂载。

### 怎样支持我的平台
在内核源代码中，drivers/mtd/maps目录包含了映射驱动。你可以使用通用的physmap.c
驱动，在内核配置时指定基地址，芯片大小，总线宽度，则physmap.c会探测闪存类型。
会使用通用的访存方法来读闪存。甚至可以处理在连续内存空间上的多块闪存芯片。
由于外部地址总线的限制，有些闪存不是使用直接存储器映射。或者在不相邻的地址空间
映射多块闪存，这时就需要你自己来根据physmap.c实现驱动。

### NOR和NAND简介
传统的FLASH必须先擦除然后才能写，现代新开发的支持bit alterability的PCM技术的
FLASH可以直接写，而不需要事先擦除。
NOR和NAND在两个主要方面不同：独立内存单元连接方式不同；提供读写的接口不同（NOR
允许随机读，NAND只允许按页访问）
NOR
可以像RAM一样随机读和写，但是必须按块的方式擦除，擦除的时候把擦除块的所有的位都
变为1，典型的块大小为64、128、256KB。对于序列数据的写操作，NOR型FLASH要比NAND型
FLASH慢许多。由于NOR支持XIP，由于可以随机读取每个地址，所以CPU一般可以在NOR上执
行程序，即支持XIP。老式的NOR闪存不支持坏块管理
NAND
工作形式更像是块设备。每个块包含许多页，这些页的典型大小为512、2048或者4096B。
每页关联一个12~16字节的错误检测或纠正码ECC，NAND依赖ECC进行纠错和检错。NAND读
和写都必须以页为最小单位，擦除必须以块为最小单位。NAND的另一个限制是同一个块内
的数据必须序列的写入。
NAND闪存也需要由设备驱动或者一个独立控制器进行坏块管理。两种坏块管理方式，一种
是划分逻辑块和物理块，保留一部分块存放映射表并处理坏块；另一种是在上电的时候扫
描每个块在RAM中创建一个坏块的映射表。NAND出厂的时候允许存在一些坏块，这个大大
降低NAND的成本。
当在NAND存储器中执行软件代码时，常使用虚存机制，代码首先被交换到RAM中，然后在
RAM中执行。不过一般NAND用来存储数据，而不是用于执行代码。

### 什么是顶端启动（top-boot）和底端启动（bottom-boot）
某些闪存被组织成在高端地址空间有一些较小的擦除块，在它下面的地址空间则是较大的
擦除块，而另一些闪存闪存被组织成底端地址空间处有一些较小的擦除块，在它后面是较
大的擦除块，根据这些小擦除块在顶端或者底端把这两类闪存分别叫做顶端启动和底端启
动闪存。
某一个擦除块的地址空间是CPU上电或者复位以后首先访问的位置，这个擦除块通常就叫做
启动块。由于有些CPU的复位向量位于地址空间的高地址处，而另一些复位向量位于地址空
间的低地址处。这样，闪存设备就有了两类风格底端启动和高端启动。根据CPU选择不同的
闪存设备。
在启动时，闪存的启动块可以加保护变为只读，由于只需要很小的代码来执行一个基本启
动，如果为这段只读启动代码分配一个小的擦除块，那么就可以较少空间的浪费，并且只
读设置可以保证当闪存其它可编程部分被不小心弄坏后仍然能够启动。

---------------------------------------
参考文件:
http://www.linux-mtd.infradead.org/doc/general.html
http://www.linux-mtd.infradead.org/faq/general.html
http://www.ssiembedded.com/embedded_linux_managing_memory.html

