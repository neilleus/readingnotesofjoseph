Author: Joseph Lee
E-Mail: fdlixiaojun@gmail.com

*******************
*    MTD概览
*******************
MTD（Memory Technology Devices）子系统在原始闪存设备上提供了一个抽象层。使得对
于不同类型和技术的闪存可以使用相同的API操作。比如NAND，OneNAND，NOR，AG-AND，
ECC'd NOR等等。

MTD子系统不处理像MMC，eMMC，SD，CompactFlash等这类块设备。这类设备并不是原始的
闪存设备，它们内部拥有一个闪存翻译层使得它们看起来像是块设备。这类设备归类于
Linux块设备子系统，不属于MTD。有个FAQ来概述了在块设备和MTD设备之间的主要区别，
在UBIFS文档的“原始闪存和FTL设备”节则更详细讨论了它们的不同。

MTD子系统有如下接口：
MTD字符设备，通常通过/dev/mtd0, /dev/mtd1等来使用，这类字符设备提供了访问原始闪
存的IO接口。它们提供了大量的ioctl调用用来擦除擦除块，标记擦除块坏或者检测擦除块
是否坏掉，获取MTD设备的信息等。
sysfs接口提供了系统内MTD设备的全部信息。这个接口可以方便的扩展并且鼓励开发者尽
可能使用sysfs接口替代旧式ioctl或者/proc/mtd接口。
/proc/mtd接口提供了通用的MTD信息。这是一个遗留接口，sysfs提供了更多信息。

MTD子系统支持带硬件或软件ECC的裸NAND闪存，OneNAND闪存，CFI NOR闪存及其它闪存类型
此外，MTD支持遗留的FTL/NFTL翻译层，M-Systems' DiskOnChip 2000 和Millennium芯片，
以及PCMCIA闪存。但是对应的驱动都很老维护更新不及时。

*******************
*    MTD测试
*******************
MTD子系统包含了一系列的测试，你可以用它来检验你的闪存硬件和驱动。这些测试用例
位于drivers/mtd/tests目录。可以通过启用CONFIG_MTD_TESTS来把它编译进内核。
测试用例包括：
    mtd_speedtest
    mtd_stresstest
    mtd_readtest
    mtd_pagetest
    mtd_oobtest
    mtd_subpagetest
    mtd_torturetest

*******************
*   mtdblock
*******************
MTD中的mtdblock驱动是一个用来在MTD设备上模拟块设备的古老工具。它甚至没有坏擦除
块处理机制，所以实际上不可以用来处理NAND闪存。并且它通过缓存一整个闪存擦除块到
RAM中来工作，提交修改请求时，首先擦除整个擦除块，然后再将修改后的内容写回。这
意味着mtdblock没有尝试做任何优化，并且在掉电时会丢失大块的数据。最后，但远不止
此，mtdblock没有实现任何平均读写演算算法。

人们经常将mtdblock认作通用FTL层并且试图在使用了mtdblock的裸闪存上使用基于块的
文件系统。大多数情况下这是错误的。换句话说，除非你确切清楚你在做什么，否则不要
使用mtdblock。

此外还有一个只读版本的这种驱动，它没有缓存和擦除/写回能力，主要用于uclinux中当
要求的RAM过大时使用。

*******************
*      FAQ
*******************
MTD设备是块设备还是字符设备？
首先，MTD表示存储技术设备，所以它就是指MTD。
传统上，UNIX只认识块设备和字符设备。字符设备是类似键盘或者鼠标的这类设备，你必
须从它读取当前数据，但是不可以定位也没有大小。块设备有固定的大小并且可以定位，
它们恰好组织成许多字节的块，通常为512字节。
闪存既不满足块设备描述也不满足字符设备的描述。它们表现的类似块设备，但又有所不
同。比如，块设备不区分写和擦除操作。因此，一种符合闪存特性的特殊设备类型诞生了，
就是MTD。
所以MTD既不是块设备，也不是字符设备。假如需要，有方法对它进行转化。但是这些转化
都和原有的不同。

闪存设备和块设备有什么不同？
以下表格描述了块设备和原始闪存设备之间的不同。注意：SSD, MMC, eMMC, RS-MMC, SD,
mini-SD, micro-SD, USB闪存, CompactFlash, MemoryStick, MemoryStick Micro以及其
它FTL设备是块设备，并不是原始闪存设备。当然，硬盘也是块设备。
    +----------------------------------+-----------------------------------+   
    |             块设备               |               MTD设备             |
    +----------------------------------+-----------------------------------+   
    |           由扇区组成             |             由擦除块组成          |
    +----------------------------------+-----------------------------------+   
    |     扇区小（512或者1024字节）    |       擦除块大（典型的128K字节）  |
    +----------------------------------+-----------------------------------+   
    | 提供2个主要操作（读扇区和写扇区）|    提供3个主要操作：读，写，擦除  |
    +----------------------------------+-----------------------------------+   
    | 坏块被硬件（或FTL）重映射并隐藏  |  坏块不会被隐藏，应该在软件中处理 |
    +----------------------------------+-----------------------------------+   
    |   扇区缺乏已坏属性（FTL会提供）  | 可擦除块会在10^3到10^5擦写之后会坏|
    +----------------------------------+-----------------------------------+   

我可以通过MTD设备挂载ext2文件系统吗？
ext2, ext3, xfs, jfs, fat以及其它传统文件系统都是与块设备匹配的，它们按照块设
备设计。闪存不是块设备，它们是完全不同的怪兽。
请不要被USB棒，MMC，SD，CompactFlash以及其它流行的便携设备迷惑，尽管它们叫做闪
存，但它们不是MTD设备。它们脱离了MTD子系统的范畴。
为了在一个MTD设备上使用某种传统文件系统，你需要一个在MTD设备上模拟块设备的软件
层。这种层往往叫做闪存翻译层（FTL）。
在Linux的MTD子系统里有一个极简单的FTL层：mtdblock。它在MTD设备上模拟块设备。还
有一个模拟只读块设备的mtdblock_ro模块。当你装载了这个模块以后，它会为系统内的
每个MTD设备创建一个块设备。然后可以通过/dev/mtdblockX设备节点访问该块设备。
但在很多时候使用mtdblock是一个坏主意，因为如果你改变了你mtdblockX设备的任何扇区
时，它会读取整个对应的擦除块到内存，然后擦除整个擦除块，改变内存中的扇区，然后
写回。问题很明显，在擦除块被擦除后突然断电了，你会丢失上面的所有块设备扇区。很
可能这个闪存就此坏掉，因为大多数情况下你所修改的块会是分区表所在的擦除块，位于
FAT/bitmap/inode 表/etc。
不幸的是，创建一个好的FTL层很难，尚且没有人为Linux实现一个。但是现在当我们拥有
UBI时，在UBI实现这个就很简单了。
很明显mtdblock_ro是为了挂载只读文件系统或只读挂载区。比如，可能有人用SquashFS作
为它存放压缩数据的方式。所以以读写方式使用mtdblock之前再三思考一下，并且不要在
NAND上使用它，因为它不支持坏块处理。

point()和unpoint()函数用来干什么？

不管我写还是擦除我的MTD设备，我总是出错？
某些NOR芯片以所有擦除块处于锁定状态的方式上电。MTD层默认并不解锁这些设备。如果
你从用户态访问这些设备，你可以使用flash_unlock工具来解锁MTD设备。如果你使用MTD
设备作为你的可读写文件系统，你还需要让bootloader在启动内核前解锁这些擦除块，或
者为你的板子在MTD映射驱动中增加解锁代码。已知会锁定的芯片有：Intel 28FxxxP30
Intel GE28F256L30T。

怎么编译mtd-utils代码树？
你需要安装工具所依赖的库。请参照mkfs.jffs2和mkfs.ubifs的依赖信息。
mkfs.jffs2组件依赖ACL，zlib库。debian下请安装libacl1-dev和zlib1g-dev包。
mkfs.ubifs组件依赖zlib，lzo和uuid库。前两个用来压缩数据，最后一个用来为文件系
统生成统一通用ID号。在Debian下要安装zlib1g-dev，libzo2-dev和uuid-dev包。



---------------------------------------
参考文件:
http://www.linux-mtd.infradead.org/doc/general.html
http://www.linux-mtd.infradead.org/faq/general.html

